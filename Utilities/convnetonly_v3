#!/bin/csh -f

# Reads NetCDF-format GENESIS GCM history files. 
# Computes and writes global and annual mean statistics for fields:
#   Surface air temperature (TS2, deg C)
#   Precipitation (PRECIP, mm/day)
#   Sea ice fraction (fraction)
#   Sea ice thickness (meters)

# Passed command-line arguments are:
#  filename  when uppercased, GENESIS history file name (w/o .nc)     
#  -lsx      append LSX to filename 
#  -d        denug version

# The ascii output is written to file is "conl_$filename"

#---------------

# Need to set NI and NA (just below), and FFLAGS (near end)
# depending on your system.

# Set locations of NetCDF system files, netcdf.h (in $NI) and
# libnetcdf.a (in $NA):
 set NI = /usr/local/include
 set NA = /usr/local/lib
#set NI = /usr/global/netcdf-3.5.1/include
#set NA = /usr/global/netcdf-3.5.1/lib

#--------------

#set host = `hostname -s`
#set hostpre = `echo $host | cut -b1-9`
#
#if ($hostpre == 'compute-0') set host = petrarch
#if ($hostpre == 'compute-2') set host = condor
#
#if ($host == iguana) then
#  set NI = /usr/include
#  set NA = /usr/bin
#else if ($host == lionxo || $host == lionxc) then
#  set NI = /usr/global/netcdf-3.5.1/include
#  set NA = /usr/global/netcdf-3.5.1/lib
#else if ($host == condor) then
#  set NI = /condor/opt/netcdf-3.5.1/include
#  set NA = /condor/opt/netcdf-3.5.1/lib
#else if ($host == petrarch) then
#  set NI = /condor/opt/netcdf/include
#  set NA = /condor/opt/netcdf/lib
#else if ($host == luna) then
#  set NI = /home/data01/pollard/include
#  set NA = /home/data01/pollard/lib
#else if ($host == uranus || $host == neptune) then
#  set NI = /usr/local/include
#  set NA = /usr/local/lib
#else
#  echo "unknown host $host"
#  exit
#endif

#--------------

# Select primary plot resolution

#set resa = 'T10'              #  T10, R15, T31, 2X2
#set resa = 'T31'              #  T10, R15, T31, 2X2
 set resa = '2X2'              #  T10, R15, T31, 2X2
#set resa = 'RCM'

if ($resa == 'T10') then
  set nlona = 32
  set nlata = 16
else if ($resa == 'R15') then
  set nlona = 48
  set nlata = 40
else if ($resa == 'T31') then
  set nlona = 96
  set nlata = 48
else if ($resa == '2X2') then
  set nlona = 180
  set nlata = 90
else if ($resa == 'RCM') then
  set nlona = 135
  set nlata = 92
endif

#--------------

# Process command line input

set filelist = ' '       # blank-delimited list of filenames
set append   = ' '       # append to file name
set debug    = 0         # 1 for debug
set ucase    = 1         # 1 to upper case entered file names
set mspath   = '.'

#set mspath     = '/home/poulsen/mom4/exp/hlfwnd/work/HISTORY/ATMOS'
#set mspath     = '/home/poulsen/mom4/exp/hlfwnd/work'

#set filelist = 'coup001 coup002 coup003 coup004 coup005 coup006 coup007 coup008 coup009 coup010 coup011 coup012 coup013 coup014 coup015 coup016 coup017 coup018 coup019 coup020'
#set filelist = 'coup024 coup025 coup026 coup027 coup028 coup029 coup030'
#set filelist = 'hlfwnd012 hlfwnd013'
set append = 'lsx'

@ k = 1
while ($k <= $#argv)
  switch ($argv[$k])
    case -lsx:
      set append = 'LSX'       # append 'LSX' to file names
      breaksw
    case -d:
      set debug = 1
      breaksw

    case -ucase:
      set ucase = 1
      breaksw
    case -noucase:
      set ucase = 0
      breaksw

    default:
      set filelist = "$filelist $argv[$k]"
  endsw
  @ k++
end

#=======================================================================

# statistics hard coded fields in plot.in
# (adapted from debplotgcmnetcdf)

cat >! plot.in << ENDplotin
=============================

  pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
   1  1  1  1  1  1  0 lmask  
  scnlv -1 nval=4 cvcode=1 real cv(nval+1) read cv
  -.5 .5 1.5 2.5 3.5
  scnlvval  cv#  unset cvf cvf = 'f4.1'  legwid = 3.8 ifill=1  ifquad=0
  iworld = 10
  *

  pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
   1  1  0  0  1  1  0 ts2
  scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
  -30 -20 -10 0 5 10 15 20 25 30 35
  scnlvval  cv#  unset cvf cvf = 'i3'  legwid = 2.8 ifill=1  ifquad=0
  iii=1 legendtype=2
  *

  pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
   1  1  0  0  1  1  0 precip
  scnlv -1 nval=9 cvcode=1 real cv(nval+1) read cv
  0 .5 1 1.5 2 3 4 5 10 15
  scnlvval  cv#  unset cvf cvf = 'f4.1'  legwid = 3.8 ifill=1  ifquad=0
  iii=1  legendtype=2 ppp=1
  *

  pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
   1  1  0  0  1  1  0 icef
  scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
  .01 .1 .2 .3 .4 .5 .6 .7 .8 .9 1.01
  scnlvval  cv#  unset cvf cvf = 'f3.1'  legwid = 3.8 ifill=1  ifquad=0
  iii=1  legendtype=2 ppp=1
  *

  pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
   1  1  0  0  1  1  0 iceh
  scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
  0 .1 .2 .3 .4 .5 1 2 3 5 10
  scnlvval  cv#  unset cvf cvf = 'f4.1'  legwid = 3.8 ifill=1  ifquad=0
  iii=1  legendtype=2 ppp=1
  *

c pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
c  1  1  0  0  1  1  0 hflxocn
c scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
c -200 -100 -50 -20 -5 0 5 20 50 100 200
c scnlvval  cv#  unset cvf cvf = 'i4'  legwid = 3.8 ifill=1  ifquad=0
c iii=1  legendtype=2 ppp=1
c *

c pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
c  1  1  0  0  1  1  0 hflxocn2
c scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
c -200 -100 -50 -20 -5 0 5 20 50 100 200
c scnlvval  cv#  unset cvf cvf = 'i4'  legwid = 3.8 ifill=1  ifquad=0
c iii=1  legendtype=2 ppp=1
c *

c pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
c  1  1  0  0  1  1  0 pmeocn
c scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
c -10 -5 -3 -1 -.3 0 .3 1 3 5 10 -100 -50 -20 -5 0 5 20 50 100 200
c scnlvval  cv#  unset cvf cvf = 'f6.1'  legwid = 5.8 ifill=1  ifquad=0
c iii=1  legendtype=2 ppp=1
c *

c pa fi p1 p2 p3 lv po cname1  cname2  cname3  cexpr
c  1  1  0  0  1  1  0 pmeocn2
c scnlv -1 nval=10 cvcode=1 real cv(nval+1) read cv
c -10 -5 -3 -1 -.3 0 .3 1 3 5 10 -100 -50 -20 -5 0 5 20 50 100 200
c scnlvval  cv#  unset cvf cvf = 'f6.1'  legwid = 5.8 ifill=1  ifquad=0
c iii=1  legendtype=2 ppp=1
c *

=============================
ENDplotin

#=======================================================================

cat >! convcom << ENDconvcom

      integer pfile, pfield, pdate, pname, pcon, parr, narea
      parameter (pfile=100, pfield=1000, pdate=1000, pname=3, pcon=10+1,
     *           parr=${nlona}*${nlata}, narea=5)
      parameter (infin=300)

      parameter (ntype=10)
      common /ciploc/ 
     *  path(10), file(pfile), ifsdev, ifshowmon, iffudge, if3mon,
     *  csuffix, cfile(ntype), cfileasc(ntype)
      character file*240, cfile*20, cfileasc*20, path*120, csuffix*8
      logical ifsdev, ifshowmon, iffudge, if3mon
      data cfile    /'MODERN', 'STAGE 3 COLD', 'STAGE 3 ADHOC',
     *                      '21 ka',        'STAGE 3 WARM',
     *               'MODERN', 'STAGE 3 COLD', 'STAGE 3 ADHOC',
     *                      '21 ka',        'STAGE 3 WARM'/
      data cfileasc /'mod', 'cold', 'adhoc', '21k', 'warm',
     *               'mod', 'cold', 'adhoc', '21k', 'warm'/

      common /diplod/ 
     *  interm, ioterm, iuin, iudata, iutab, iubasin,
     *  nulhdr, ndens, nurecl, mbdate,
     *  clabel, clabdat, runtitle, runtita, runtitb,
     *  nlev, sig(100), sigkmh(100), dsigma(100),

     *  datea(pdate), dateb(pdate), ndate, icalendar,

     *  alon(1000), alat(1000), alev(1000), atim(1000)

      character clabel*8,clabdat*8, runtitle*80, runtita*80, runtitb*80

      common /cworkc/
     *   arrtmp(parr)

ENDconvcom

#=======================================================================

cat >! convnetcom << ENDconvnetcom

      integer*4  ncid, varid, rcode,
     *           lonid,latid,levid,timid,nlon4,nlat4,nlev4,ntim4,ndims,
     *           start(3), count(3), starta(4), counta(4)
      real*4 alon4(1000), alat4(1000), alev4(1000), atim4(1000),
     *       var4(parr)
      character cerr*80
      character*80 function nf_strerror
      common /cnetc/ ncid, start, count, starta, counta

ENDconvnetcom

#=======================================================================

cat >! conv.F << ENDconv

      program conv

c        Reads history files and writes an ascii gf-input file
c        for plotting requested fields.

#include "convcom"
#include "convnetcom"
#include "${NI}/netcdf.inc"

      dimension ifila(10), iper(10), iper1(10), iper2(10), iper3(10),
     *          level(10), ipole(10), nname(10), ifilin(10), ifvec(10)
      character cname(10,pname)*8, cexpr(10)*200, contour(10,pcon)*200,
     *          cnamev(10,pname)*8, cexprv(10)*200
      data cnamev /10*'V', 20*' '/
      data cexprv /10*'V'/

      character cmd*200, cform*30, cskip*200, ctmp*200
      data interm, ioterm /5, 6/
      data iuin, iudata, iutab, iubasin /76, 77, 78, 99/

      character*80 carg1
      integer getarg

c     namelist /filelist/ file, path, if3mon, csuffix, icalendar, ifsdev

c        set flags in combatch: show-month (ifshowmon), standard-devs
c        (ifsdev), fudge to treat file#1/per#1 as Jan, file#2/per#1
c        as Jul (iffudge), 3-month averages (if3mon, from command line)

      ifshowmon = .true.
      ifsdev    = .false.
      iffudge   = .false.
      if3mon    = .false.
      csuffix   = ' '
      icalendar = 0

c        Set history filenames from namelist input

      do i=1,pfile
        file(i) = ' '
      enddo
      do j=1,10
        path(j) = ' '
      enddo

c     open (iuin, file='plot.in', status='old', err=2)
c     goto 4
c  2  write (ioterm,'(/a)')
c    *   '*** Error: plot request file plot.in not found'
c     stop
c  4  continue 
c     read (iuin, filelist)
c     close (iuin)

c        Set input file and output file names

      n = iargc()
      write (*,*) n
      if (n.eq.1) then
        ierb = getarg(1,carg1)
      else
        write (6,*) '*** Error: no filename argument provided'
        stop
      endif
      file(1) = carg1

      do j=1,10
       if (path(j).ne.' ') then
          n = lenchr(path(j))
          if (path(j)(n:n).ne.'/') then
            n = n+1
            path(j)(n:n) = '/'
          endif
          do i = 1+(j-1)*10, 10+(j-1)*10 
            if (file(i).ne.' ' .and. file(i)(1:1).ne.'/') then 
              file(i) = path(j)(1:n) // file(i)
            endif
          enddo
        endif
      enddo 

c        Calculate number of history files from cmd-line/script input

      do k=1,10
        do i = k*10, k*10-9,-1
          if (file(i).ne.' ') then
            ifilin(k) = -i
            goto 10
          endif
        enddo
        ifilin(k) = 0
   10   continue
      enddo

c        Open new gf data file (data_gcm) and stat.info file (out_gcm)

      ier = ishell('rm -f data_gcm')
      ier = ishell('rm -f out_gcm')
      open (iudata, file='data_gcm', status='new')
      open (iutab,  file='out_gcm', status='new')

c        Open plot request file (again), skip over namelist section

      open (iuin, file='plot.in', status='old')

      do i=1,100000
        read (iuin,'(a)', err=45, end=45) ctmp
        if (ctmp(1:10).eq.'==========') goto 46
      enddo
   45 write (ioterm,'(/a)')
     *  '*** Error: no  request header (==========) found in plot.in'
      stop
   46 continue

c        Loop over each requested field/expression (each request can
c        include multiple periods and/or two-panel plots)
 
c----------------------------
      do 1000 ireq = 1,100000
c----------------------------

c           Skip blank or commented-out lines till next header line

   50    read (iuin,'(a)',end=2000) cskip
         if (cskip.eq.' ' .or. cskip(1:1).eq.'c' .or. cskip(1:1).eq.'C')
     *     goto 50
         if (cskip(1:10).eq.'==========') goto 2000
         if (cskip(1:4).ne.'  pa' .and. cskip(1:4).ne.'  PA') then
           write(ioterm,*) '*** Syntax error at start of request block:'
           write(ioterm,*) cskip
           stop
         endif

c           Read request line

         read(iuin,60) icode, ifila(1), iper1(1), iper2(1), iper3(1),
     *                 level(1), ipole(1),
     *                 (cname(1,i),i=1,pname), cexpr(1)
   60    format(1x,7i3,1x,3a8,a)

c           Set npanel, nline and ifdif

         if (icode.eq.-1) then
           npanel = 1
           nline = 2
           ifdif = 1
         else
           npanel = icode
           nline = icode
           ifdif = 0
         endif

c           Read other request lines if multi-panel or difference plot

         if (nline.ge.2) then
           do 62 n=2,nline
             read(iuin,60) icode,ifila(n),iper1(n),iper2(n),iper3(n),
     *                     level(n),ipole(n),
     *                     (cname(n,i),i=1,pname), cexpr(n)
  62       continue
         endif

c           Override number of history files from cmd-line/script input

         do 63 n=1,nline
           if (ifila(n).eq.-10) then
              ifila(n) = ifilin(1)
           else if (ifila(n).eq.-20) then
              ifila(n) = ifilin(2)
           else if (ifila(n).eq.-30) then
              ifila(n) = ifilin(3)
           else if (ifila(n).eq.-40) then
              ifila(n) = ifilin(4)
           else if (ifila(n).eq.-50) then
              ifila(n) = ifilin(5)
           else if (ifila(n).eq.-60) then
              ifila(n) = ifilin(6)
           else if (ifila(n).eq.-70) then
              ifila(n) = ifilin(7)
           else if (ifila(n).eq.-80) then
              ifila(n) = ifilin(8)
           else if (ifila(n).eq.-90) then
              ifila(n) = ifilin(9)
           else if (ifila(n).eq.-99) then    ! limited to i3
              ifila(n) = ifilin(10)
           endif
   63    continue

c           Read contouring info (consists of gf stmts, up to pcon-1
c           lines for each panel, terminated by 1st non-blank="*")

         do 64 ipan=1,npanel
           do 65 i=1,pcon

             read (iuin,'(a)') contour(ipan,i)
             call lstrip (contour(ipan,i))

c            If blank line, copy last set to any remaining, skip out:
             if (contour(ipan,i).eq.' '.or.contour(ipan,i).eq.'c' .or.
     *           contour(ipan,i).eq.'C') then
               do 66 jpan=ipan,npanel
                 do 67 j=i,pcon
                   contour(jpan,j) = contour(ipan-1,j)
   67            continue
   66          continue
               goto 69

c            Termination for each set of lines for one panel:
             else if (contour(ipan,i)(1:1).eq.'*') then
               do 68 j=i,pcon
                 contour(ipan,j) = ' '
   68          continue
               goto 64
             endif

   65      continue
   64    continue
   69    continue

c          Set number of field names, upper field names and expressions.
c          Loop either for multi-panels (npanel>=2,ifdif=0) or for
c          difference plots (npanel=1,ifdif=1).

         do 70 n=1,nline
           nname(n) = 0
           do 72 i=1,pname    
             call lstrip(cname(n,i))
             call upper(cname(n,i))
             if (cname(n,i).ne.' ') nname(n) = nname(n) + 1
   72      continue
           m = lenchr(cname(n,1))
           if (m.gt.3 .and. cname(n,1)(m-2:m).eq.'VEC') then
             ifvec(n) = 1
             cname(n,1) = cname(n,1)(1:m-3)
           else
             ifvec(n) = 0
           endif
           call lstrip(cexpr(n))
           call upper(cexpr(n))
           if (cexpr(n).eq.' ') cexpr(n) = cname(n,1)
   70    continue

         write(ioterm,80) ireq, cexpr(1)(1:lenchr(cexpr(1)))
   80    format(/'Processing request',i4,'   field: ',a)

c           Loop over periods, calling dopanel to process each panel.
c           Adjust limits so get last iper2(1) value even if it would
c           be missed by the do loop interval

         do 100 iperx = iper1(1),iper2(1)+iper3(1),iper3(1)

           iper(1) = min (iperx, iper2(1))
           if (nline.ge.2) then 
             do 102 n=1,nline
               iper(n) = iper1(n) + iper3(n)*((iperx-iper1(1))/iper3(1))
               iper(n) = min (iper(n), iper2(n))
  102        continue
           endif

           do 104 ipan = 1,npanel
c            if (ipole(ipan).eq.3 .or. ipole(ipan).eq.4) then
c              if3mon = .true.
c            else
c              if3mon = .false.
c            endif
             call dopanel (ipan, npanel, ifdif,  
     *                     ifila, iper, level, ipole, 
     *                     nname, cname, cexpr, contour,
     *                     nlon, nlat)
             if (ifvec(ipan).eq.1) then
               call dopanel (ipan, npanel, ifdif,
     *                       ifila, iper, level, ipole,
     *                       nname, cnamev, cexprv, contour,
     *                       nlon, nlat)
             endif
  104      continue

           if (iper(1).eq.iper2(1)) goto 110

  100    continue
  110    continue

c-------------
 1000 continue
c-------------

c        Write gf "end" statement to signal end of file for gf

 2000 write(iudata,2002)
 2002 format('end')
      close (iudata)
c     write (iutab,"(/80('-'))")
      close (iutab)
      close (iuin)
      rcode = nf_close (ncid)

      stop
      end

c-----------------------------------------------------------------------

      subroutine readfile (ifile, imap, nlon, nlat)

c        Opens local history file # ifile. Sets nlon and nlat, 
c        and saves land-ocean mask in imap for later calculation of 
c        global means.

#include "convcom"
#include "convnetcom"
#include "${NI}/netcdf.inc"

      character*80 file0, file1
      character*200 cmd
      dimension imap(parr), work(parr)
      logical lfirst, ifexist0, ifexist1
      save lfirst
      data lfirst /.true./

      dimension sigl18(19)
      data sigl18 /
     *  .000, .008, .022, .049, .083, .118,
     *  .163, .219, .288, .367, .456, .551,
     *  .649, .744, .831, .903, .956, .985, 1.000 /

c        Initialize land-ocean mask to -1 (will be set below if found)

      if (lfirst) then
        do 2 i=1,parr
           imap(i) = -1
    2   continue
        lfirst = .false.
      endif

      ifgotmap = 0

c        Test if file to be opened exists

      file0 = file(ifile)(1:lenchr(file(ifile)))
      inquire (file=file0, exist=ifexist0)
      if (.not.ifexist0) then
        write (ioterm,700) file0(1:lenchr(file0))
  700   format(/'*** Error: history file ',a,' not found')
        stop
      endif

c        Open existing file

      rcode = nf_open (file0, ncnowrite, ncid)

c        Get grid axes

      rcode = nf_inq_dimid (ncid,  'lon',  lonid)
      rcode = nf_inq_dimlen (ncid, lonid, nlon4)
      rcode = nf_inq_varid (ncid,  'lon',  varid)
      rcode = nf_get_var_real (ncid, varid, alon4)

      rcode = nf_inq_dimid (ncid,  'lat',  latid)
      rcode = nf_inq_dimlen (ncid, latid, nlat4)
      rcode = nf_inq_varid (ncid,  'lat',  varid)
      rcode = nf_get_var_real (ncid, varid, alat4)

      rcode = nf_inq_dimid (ncid,  'lev',  levid)
      if (rcode.ne.nf_noerr) then
         nlev4 = 1
      else
        rcode = nf_inq_dimlen (ncid, levid, nlev4)
        rcode = nf_inq_varid (ncid,  'lev',  varid)
        rcode = nf_get_var_real (ncid, varid, alev4)
      endif
      nlev4 = max (nlev4, 2)    ! for ts2_m, etc


      rcode = nf_inq_dimid (ncid,  'time',  timid)
      rcode = nf_inq_dimlen (ncid, timid, ntim4)
      rcode = nf_inq_varid (ncid,  'time',  varid)
      rcode = nf_get_var_real (ncid, varid, atim4)

      nlon = nlon4
      do i=1,nlon
        alon(i) = alon4(i)
      enddo

      nlat = nlat4
      do j=1,nlat
        alat(j) = alat4(j)
      enddo

      nlev = nlev4
      if (nlev.gt.2) then
        do k=1,nlev
          sig(k) = alev4(k)
        enddo
      else
        sig(1) = 0.
        sig(2) = 1.
      endif

      nlevp = nlev + 1
      if (nlev.eq.18) then
        do k=1,nlevp
          sigkmh(k) = sigl18(k)
        enddo
      else
        do k=2,nlev
          sigkmh(k) = 0.5*(sig(k-1)+sig(k))
        enddo
        sigkmh(1) = 0.
        sigkmh(nlevp) = 1.
      endif
      do k=1,nlev
        dsigma(k) = sigkmh(k+1)- sigkmh(k)
      enddo

      ndate = ntim4
      if (ndate.eq.1) then
        datea(1) = atim4(1) - 0.5
        dateb(1) = atim4(1) + 0.5
      else
        do m=2,ndate
          datea(m) = 0.5*(atim4(m-1)+atim4(m))
        enddo
        do m=1,ndate-1
          dateb(m) = 0.5*(atim4(m+1)+atim4(m))
        enddo
        datea(1)     = 1.5*atim4(1)     - 0.5*atim4(2)
        dateb(ndate) = 1.5*atim4(ndate) - 0.5*atim4(ndate-1)
      endif

      start(1) = 1
      count(1) = nlon
      start(2) = 1
      count(2) = nlat

      starta(1) = 1
      counta(1) = nlon
      starta(2) = 1
      counta(2) = nlat

c        Get run title

      rcode = nf_get_att_text (ncid, nf_global, 'title', runtitle)
      do i=1,80
       if (ichar(runtitle(i:i)).lt.32 .or.
     *     ichar(runtitle(i:i)).gt.126    ) runtitle(i:i) = ' '
      enddo

c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      if (nlon.eq.$nlona.and.nlat.eq.$nlata .and. ifgotmap.eq.0) then
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

c             Read land-ocean mask (from first occurrence on file).
c             If not present or if this file's resolution is not the
c             primary one, leave alone.

         clabel = 'LSX'
         rcode = nf_inq_varid (ncid, 'LMASK', varid)
         if (rcode.ne.nf_noerr) then
           rcode = nf_inq_varid (ncid, 'ORO', varid)
           clabel = 'CCM'
         endif

         start(3) = 1
         count(3) = 1
         rcode = nf_get_vara_real (ncid, varid, start, count, var4)

         do m=1,nlon*nlat
           imap(m) = nint (var4(m))
c          Convert lsx mask to 0=ocn/seaice,1=land,2=icesheet for gf
           if (imap(m).ge.3) imap(m) = 0
         enddo

c        write (*,'(180i1)') (imap(m),m=1,nlon*nlat)

c>>>>>>>>>>
      endif
c>>>>>>>>>>

      return
      end 

c-----------------------------------------------------------------------

      subroutine readfiel (curf, iper, ifilin, 
     *                     level, arrin, imap, cunits, nlon,nlat, iferr)

c        Loops over requested files and periods to form a data array
c        arrin for field curf. Calls readfiel2 to actually do single
c        reads of history files. Handles calculation of multi-file
c        standard deviations if requested.

c        If a "special field", calls readfiel2 several times for allc
c        necessary "basic" fields, and then manipulates them to form
c        the requested field.

#include "convcom"

      character curf*8, curfmmr*8, cunits*(*)
      dimension arrin(parr), imap(parr), arr(parr), arrsd(parr,10)
      dimension arrza(parr), arrzb(parr), arrzc(parr), arrzd(parr),
     *          arrze(parr), arrzf(parr),
     *          arrzg(parr), arrzh(parr),
     *          arrzi(parr), arrzj(parr),
     *          arrzk(parr), arrzl(parr)
      dimension basin($nlona,$nlata), qtrans($nlata+1), atrans($nlata+1)
      character ctmpnam*8
      parameter (pi=3.14159265358979)

      parameter (nbasin=21)
      dimension abasin(nbasin), rbasin(nbasin)
      character cbasin(2,nbasin)*50
      save cbasin
c     Mike Coe's 2x2 basins and UNESCO runoff data (mm/yr):
      data cbasin /
     *  '   1. Arctic basin,   N.America ',   '     ',      ! 1
     *  '   2. Arctic basin,   Eurasia   ',   ' 357 ',      ! 2
     *  '   3. Atl.+Arc basin, N.America ',   ' 282 ',      ! 3
     *  '   4. Atlantic basin, S.America ',   ' 685 ',      ! 4
     *  '   5. Atlantic basin, Eurasia   ',   ' 312 ',      ! 5
     *  '   6. Atlantic basin, Africa    ',   ' 241 ',      ! 6
     *  '   7. Atlantic basin, Antarctica',   '     ',      ! 7
     *  '   8. Indian basin,   Africa    ',   ' 144 ',      ! 8
     *  '   9. Indian basin,   Eurasia   ',   ' 481 ',      ! 9
     *  'A.10. Indian basin,   Australia ',   ' 172 ',      ! 10 (A)
     *  'B.11. Indian basin,   Antarctica',   ' 149 ',      ! 11 (B)
     *  'C.12. Pacific basin,  N.America ',   ' 465 ',      ! 12 (C)
     *  'D.13. Pacific basin,  S.America ',   '1076*',      ! 13 (D)
     *  'E.14. Pacific basin,  Asia      ',   ' 626 ',      ! 14 (E)
     *  'F.15. Pacific basin,  Australia ',   '1050*',      ! 15 (F)
     *  'G.16. Pacific basin,  Antarctica',   ' 193 ',      ! 16 (G)
     *  'H.17. Internal,       Africa    ',   '  16 ',      ! 17 (H)
     *  'I.18. Internal,       Eurasia   ',   '  53 ',      ! 18 (I)
     *  'J.19. Internal,       Australia ',   '   2*',      ! 19 (J)
     *  'K.20. Internal,       S.America ',   '     ',      ! 20 (K)
     *  'L.21. Internal,       N.America ',   '     ' /     ! 21 (L)

      dimension dsigma18(18), sigl18(19)
      save dsigma18, sigl18
      data sigl18 /
     *  .000, .008, .022, .049, .083, .118,
     *  .163, .219, .288, .367, .456, .551,
     *  .649, .744, .831, .903, .956, .985, 1.000 /

      do k=1,18
        dsigma18(k) = sigl18(k+1) - sigl18(k)
      enddo

      lcurf = lenchr(curf)

c        Loop over files if multi-file requested

      if (ifilin.ge.0) then
        ifile1 = ifilin
        ifile2 = ifilin
      else
        n = (-ifilin-1)/10 
        ifile1 = 1 + n*10
        ifile2 = -ifilin
      endif

c        Fudge to treat file#1/per#1 as Jan, file#2/per#1 as Jul

      if (iffudge) then
        if (ifilin.eq.-2) then
          if (iper.eq.1) then
            ifile1 = 1
            ifile2 = 1
          else if (iper.eq.7) then
            ifile1 = 2
            ifile2 = 2
          endif 
        else if (ifilin.eq.-12) then
          if (iper.eq.1) then
            ifile1 = 11
            ifile2 = 11
          else if (iper.eq.7) then
            ifile1 = 12
            ifile2 = 12
          endif
        endif
      endif

      call zero (arrin, parr)

c==================================
      do 1000 ifile = ifile1,ifile2
c==================================

c-------------------------
c       "Special" requests (must be ~linear...readfiel2 time-averages)
c-------------------------

        if (curf.eq.'SABTPM') then

          call readfiel2 ('SABTP   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('SABAT   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 301 i=1,nlon*nlat
            arr(i) = arrza(i) + arrzb(i)
  301     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'SABTPE') then

          call readfiel2 ('TSOLRDCS', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('MSWD    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 3010 i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
 3010     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'CRF_IRM') then

          call readfiel2 ('FIRTP   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('CLRLT   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 3012 i=1,nlon*nlat
            arr(i) = arrzb(i) - arrza(i)
 3012     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'CRF_IRE') then

          call readfiel2 ('MLWD    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('MLWCSD  ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 3014 i=1,nlon*nlat
            arr(i) = arrzb(i) - arrza(i)
 3014     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'CRF_SWM') then

          call readfiel2 ('SABTP   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('SABAT   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('CLRST   ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          do 3016 i=1,nlon*nlat
            arr(i) = arrzc(i) - (arrza(i)+arrzb(i))
 3016     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'CRF_SWE') then

          call readfiel2 ('MSWD    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('MSWCSD  ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 3018 i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
 3018     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'CRF_SWS') then

          call readfiel2 ('FRSAV    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSAN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSAVC  ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSANC  ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do 3019 i=1,nlon*nlat
            arr(i) = arrzc(i) + arrzd(i) - arrza(i) - arrzb(i)
 3019     continue
          cunits = 'W/m@S@2@N@'

        else if (curf.eq.'SURRAD') then

          call readfiel2 ('FRSIV   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) + arrzb(i)
          enddo

        else if (curf.eq.'ALBSFCV') then

          call readfiel2 ('FRSAV   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIV   ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            zin = arrzc(i)
            arr(i) = 1. - cvmgt( arrza(i)/max(zin,.001),
     *                           1., zin.ge.001 )
          enddo
          cunits = ' '

        else if (curf.eq.'ALBSFCN') then

          call readfiel2 ('FRSAN   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIN   ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            zin = arrzc(i)
            arr(i) = 1. - cvmgt( arrza(i)/max(zin,.001),
     *                           1., zin.ge.001 )
          enddo
          cunits = ' '

        else if (curf.eq.'ALBSFC') then

          call readfiel2 ('FRSAV   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSAN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIV   ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIN   ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do 302 i=1,nlon*nlat
            zin = arrzc(i) + arrzd(i)
            arr(i) = 1. - cvmgt( (arrza(i)+arrzb(i))/max(zin,.001),
     *                           1., zin.ge.001 )
  302     continue
          cunits = ' '

        else if (curf.eq.'DALBSFC') then

          call readfiel2 ('FRSAV   ', iper, ifile-10, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSAN   ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIV   ', iper, ifile-10, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIN   ', iper, ifile-10, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            zin = arrzc(i) + arrzd(i)
            arrze(i) = 1. - cvmgt( (arrza(i)+arrzb(i))/max(zin,.001),
     *                           1., zin.ge.001 )
          enddo

          call readfiel2 ('FRSAV   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSAN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIV   ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIN   ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            zin = arrzc(i) + arrzd(i)
            arr(i) = 1. - cvmgt( (arrza(i)+arrzb(i))/max(zin,.001),
     *                           1., zin.ge.001 ) - arrze(i)
          enddo

          cunits = ' '

        else if (curf.eq.'ALBPLA') then

          call readfiel2 ('SABTP', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('SABAT', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('SOLIN', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = 1. - cvmgt( (arrza(i)+arrzb(i))/max(arrzc(i),.001),
     *                           1., arrzc(i).ge.001 )
          enddo
          cunits = ' '

        else if (curf.eq.'NDVI') then

          call readfiel2 ('FRSAVC  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSIVC  ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSANC  ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSINC  ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do 3020 i=1,nlon*nlat
            zalbv = 1. - arrza(i) / max (arrzb(i),0.1)
            zalbn = 1. - arrzc(i) / max (arrzd(i),0.1)
            arr(i) = (zalbn - zalbv) / (zalbn + zalbv)
 3020     continue
          cunits = ' '

        else if (curf.eq.'FRSATOT') then

          call readfiel2 ('FRSAV   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRSAN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 303 i=1,nlon*nlat
            arr(i) = arrza(i) + arrzb(i)
  303     continue

        else if (curf.eq.'PRECIP') then

          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arr,imap,cunits,nlon,nlat,iferr)
          if (iferr.ne.0) then
            iferr = 0
            call readfiel2 ('PRECL   ', iper, ifile, 
     *                      level,arrza,imap,cunits,nlon,nlat,iferr)
            call readfiel2 ('PRECC   ', iper, ifile, 
     *                      level,arrzb,imap,cunits,nlon,nlat,iferr)
            do 304 i=1,nlon*nlat
              arr(i) = arrza(i) + arrzb(i)
  304       continue
          endif

        else if (curf.eq.'AVAP') then

          call readfiel2 ('AVAP    ', iper, ifile, 
     *                    level,arr,imap,cunits,nlon,nlat,iferr)
          if (iferr.ne.0) then
            iferr = 0
            call readfiel2 ('QFLR    ', iper, ifile, 
     *                      level,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = (arrza(i)/2.5104e6) * 86400.
            enddo
            cunits = 'mm/day'
          endif

        else if (curf.eq.'BOWEN') then

          call readfiel2 ('HFLR    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('QFLR    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 305 i=1,nlon*nlat
            if (abs(arrzb(i)).gt..0001) then
              arr(i) = arrza(i) / arrzb(i)
            else
              arr(i) = 0.
            endif
  305     continue
          cunits = ' '

        else if (curf.eq.'TRAVAP') then

          call readfiel2 ('TRANSP  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('AVAP    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 306 i=1,nlon*nlat
            if (abs(arrzb(i)).gt.1.e-10) then
              arr(i) = arrza(i) / arrzb(i)
            else
              arr(i) = 0.
            endif
  306     continue
          cunits = ' '

        else if (curf.eq.'PRECIP3') then

          call zero (arr, parr)
          do n=1,3
            call readfiel2 ('PRECIP  ', iper, ifile-n+1,
     *                       level, arrza, imap, cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = arr(i) +  arrza(i)/3.
            enddo
          enddo

        else if (curf.eq.'RH850') then

          call readfiel2 ('RHUMID  ', iper, ifile,
     *                    14,arrza,imap,cunits,nlon,nlat,iferr) ! .787
          call readfiel2 ('RHUMID  ', iper, ifile,
     *                    15,arrzb,imap,cunits,nlon,nlat,iferr) ! .866
          do i=1,nlon*nlat
            arr(i) = ((.850-.787)*arrzb(i) +  (.866-.850)*arrza(i))
     *             / (.866-.787)
          enddo

        else if (curf.eq.'VQTOT') then

          call zero (arr, parr)
          do k=1,18
            call readfiel2 ('VQ      ', iper, ifile,
     *                      k,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = arr(i) +  1.e3*arrza(i)*dsigma18(k)
            enddo
          enddo
          cunits = 'm/s g/kg'

        else if (curf.eq.'QTOT') then

          call zero (arr, parr)
          do k=1,18
            call readfiel2 ('Q       ', iper, ifile,
     *                      k,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = arr(i) +  1.e3*arrza(i)*dsigma18(k)
            enddo
          enddo
          cunits = 'm/s g/kg'

        else if (curf.eq.'WQ866') then

          call readfiel2 ('WQ      ', iper, ifile,
     *                     15,arr,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
c           kg/kg -> g/kg, N/m2/s -> 10^-4 mb/s
            arr(i) = 1.e3 * 1.e2 * arr(i)  
          enddo
          cunits = 'mb/s g/k'

        else if (curf.eq.'WRAT') then

          call readfiel2 ('U      ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('V      ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('SURWIND ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
              arr(i) = arrzc(i) / sqrt(arrza(i)**2 + arrzb(i)**2)
          enddo
          cunits = ' '

        else if (curf.eq.'SLT') then

          call readfiel2 ('T       ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('TOPOG   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) + .0065*arrzb(i)
          enddo
          cunits = '@S@o@N@C'

        else if (curf.eq.'TS2MAX') then

          do i=1,nlon*nlat
            arr(i) = -1.e20
          enddo
          do k=1,12
            call readfiel2 ('TS2     ', k, ifile, 
     *                       level,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = max (arrza(i),arr(i))
            enddo
          enddo

        else if (curf.eq.'TS2RAN') then

          call readfiel2 ('TS2_M   ', iper, ifile, 
     *                       1,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('TS2_M   ', iper, ifile, 
     *                       2,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrzb(i) - arrza(i)
          enddo

        else if (curf.eq.'TS2MIN') then

          do i=1,nlon*nlat
            arr(i) =  1.e20
          enddo
          do k=1,12
            call readfiel2 ('TS2     ', k, ifile, 
     *                       level,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = min (arrza(i),arr(i))
            enddo
          enddo

        else if (curf.eq.'TPGLAC') then

          do i=1,nlon*nlat
            arrza(i) = -1.e20
          enddo
          do k=1,12
            call readfiel2 ('TS2     ', k, ifile, 
     *                       level,arrzb,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arrza(i) = max (arrza(i),arrzb(i))
            enddo
          enddo

          call readfiel2 ('PRECIP  ', 0, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)

          do i=1,nlon*nlat
            if (arrza(i).lt.13. .and. arrzc(i).gt.4.) then
              arr(i) = 1.
            else
              arr(i) = 0.
            endif
          enddo
          cunits = ' '

        else if (curf.eq.'TS2MIN') then

          do i=1,nlon*nlat
            arr(i) = 1.e20
          enddo
          do k=1,12
            call readfiel2 ('TS2     ', k, ifile, 
     *                       level,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = min (arrza(i),arr(i))
            enddo
          enddo

        else if (curf.eq.'DTS2    ') then

          call readfiel2 ('TS2     ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('TS2     ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo

        else if (curf.eq.'DTS') then

          call readfiel2 ('TS      ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('TS      ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo

        else if (curf.eq.'TSO') then

          call readfiel2 ('TS      ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo

        else if (curf.eq.'DTSO') then

          call readfiel2 ('TS      ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('TS      ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo

        else if (curf.eq.'DPRECIP') then

          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('PRECIP  ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo

        else if (curf.eq.'DSOLIN') then

          call readfiel2 ('SOLIN   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('SOLIN   ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo

        else if (curf.eq.'DLAIT') then

          call readfiel2 ('LAIT    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('LAIT    ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)

          do i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
          enddo
          cunits = ' '

        else if (curf.eq.'LAIB') then

c         biome3.5 lai (where veg): inverts code in vegdat_biome
          call readfiel2 ('LAIT    ', iper, ifile, 
     *                    level,arr,imap,cunits,nlon,nlat,iferr)

          do i=1,nlon*nlat
            if (arr(i).lt.2.) arr(i) = sqrt (2.*arr(i))
          enddo

        else if (curf.eq.'FVEGB') then

c         biome3.5 fractional veg cover: inverts code in vegdat_biome
          call readfiel2 ('LAIT    ', iper, ifile, 
     *                    level,arr,imap,cunits,nlon,nlat,iferr)

          do i=1,nlon*nlat
            if (arr(i).lt.2.) arr(i) = sqrt (2.*arr(i))
            arr(i) = min (1., arr(i)/2.)
          enddo

        else if (curf(1:2).eq.'C_' .or. curf(1:2).eq.'D_') then

c         For "CAL" time means allowing for different month 
c         lengths, set by icalendar (in common, used in readfiel2).

          ctmpnam = curf(3:)
          icalendsav = icalendar

          icalendar = 126             ! use 126 ka calendar
          call readfiel2 (ctmpnam, iper, ifile,
     *                    level,arr,imap,cunits,nlon,nlat,iferr)

          if (curf(1:2).eq.'D_') then 
            icalendar = 0             ! use modern calendar
            call readfiel2 (ctmpnam, iper, ifile-10,
     *                      level,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arr(i) = arr(i) - arrza(i)
            enddo
          endif

          icalendar = icalendsav

        else if (curf.eq.'TSOC') then

          call readfiel2 ('TS      ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          do i=1,nlon*nlat
            arr(i) = max (arrza(i), -2.)
          enddo

        else if (curf.eq.'TDIFOBS') then

          call readfiel2 ('TS2     ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          runtita = runtitle
c         Crutcher/IASA:
          call readfiel2 ('T_CRUCD ', iper, 46,
     *                    1,    arrzb,imap,cunits,nlon,nlat,iferr)
c         Shea:
c         call readfiel2 ('SAT     ', iper, 42,
c    *                    1,    arrzb,imap,cunits,nlon,nlat,iferr)
c         Legates+Willmott:
c         call readfiel2 ('T_CDATA ', iper, 44,
c    *                    1,    arrzb,imap,cunits,nlon,nlat,iferr)
          runtitb = runtitle
          runtitle = runtita(1:lenchr(runtita))//' minus '//runtitb

ccor      correct for model spectral topog ripples using 6.5 deg/km
ccor      call readfiel2 ('TOPOG  ', iper, 1, 
ccor *                    1,    arrzc,imap,cunits,nlon,nlat,iferr)
ccor      call readfiel2 ('TOPOGUN ', iper, 1, 
ccor *                    1,    arrzd,imap,cunits,nlon,nlat,iferr)
          do 308 i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
ccor        arr(i) = arrza(i) - arrzb(i) + .0065*(arrzc(i)-arrzd(i))
  308     continue


ccor    else if (curf.eq.'TA' .or. curf.eq.'TS' .or.
ccor *           curf.eq.'TS2'.or. curf.eq.'TS10' ) then
ccor      call readfiel2 (curf, iper, ifile, 
ccor *                    level,arrza,imap,cunits,nlon,nlat,iferr)
ccor      call readfiel2 ('TOPOG   ', iper, 1, 
ccor *                    1,    arrzc,imap,cunits,nlon,nlat,iferr)
ccor      call readfiel2 ('TOPOGUN ', iper, 1, 
ccor *                    1,    arrzd,imap,cunits,nlon,nlat,iferr)
ccor      correct for model spectral topog ripples using 6.5 deg/km
ccor      do 309 i=1,nlon*nlat
ccor        arr(i) = arrza(i) + .0065*(arrzc(i)-arrzd(i))
ccor        arr(i) = arrza(i)
c 309     continue

        else if (curf.eq.'TOCNDIF') then

          call readfiel2 ('ICEF    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('TS      ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          runtita = runtitle
c         Crutcher/IASA:
          call readfiel2 ('T_CRUCD ', iper, 46,
     *                    1,    arrzc,imap,cunits,nlon,nlat,iferr)
c         Shea:
c         call readfiel2 ('SAT     ', iper, 42,
c    *                    1,    arrzc,imap,cunits,nlon,nlat,iferr)
c         Legates+Willmott:
c         call readfiel2 ('T_CDATA ', iper, 44,
c    *                    1,    arrzc,imap,cunits,nlon,nlat,iferr)
          runtitb = runtitle
          runtitle = runtita(1:lenchr(runtita))//' minus '//runtitb
          do 310 i=1,nlon*nlat
            if (arrza(i).lt.0.05) then
              arr(i) = arrzb(i) - arrzc(i)
            else
              arr(i) = 0.
            endif
  310     continue

        else if (curf.eq.'RUNOFT') then

          call readfiel2 ('RUNOFF  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('DRAIN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 311 i=1,nlon*nlat
            arr(i) = arrza(i) + arrzb(i)
  311     continue

c----
        else if (curf.eq.'RUNOFB') then

          call readfiel2 ('RUNOFF  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('DRAIN   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 3110 i=1,nlon*nlat
            arr(i) = arrza(i) + arrzb(i)
 3110     continue

c            Read Genesis data input file for Mike Coe's basin labels:

          if (ifile.eq.ifile1) then
            open (iubasin, status='old',
     *      file='/iguana/s1/pollard/Datafiles/V2/data_basin_$resa')
            call readdata (iubasin, basin, xdum, nlon, nlat,
     *                     'BASN    ', 'lsx drainage basins', 1)
           close(iubasin)

c              Calculate rbasin (runoff+drainage in each basin, mm/year)

            call zero (abasin, nbasin)
            call zero (rbasin, nbasin)
          endif

          do 3112 j=1,nlat
            zlat = -0.5*pi + pi*(j-.5)/nlat
            darea = (2.*pi/nlon) * cos(zlat) * (pi/nlat)
            do 3114 i=1,nlon
              n = nlon*(j-1) + i
              ib = nint(basin(i,j))
              if (ib.ge.1 .and. ib.le.nbasin) then
                if (ifile.eq.ifile1) abasin(ib) = abasin(ib) + darea
                rbasin(ib) = rbasin(ib) + darea*arr(n)*365.
              endif
 3114       continue
 3112     continue

          if (ifile.eq.ifile2) then

c              Since UNESCO data combines Arctic N.America (#1) and
c              Atlantic N.America (#3), do same for model, put in #3

            abasin(3) = abasin(1) + abasin(3)
            rbasin(3) = rbasin(1) + rbasin(3)

            do 3116 ib=1,nbasin
              rbasin(ib) = rbasin(ib) / (ifile2 - ifile1 + 1)
              if (abasin(ib).gt.0.) rbasin(ib) = rbasin(ib)/abasin(ib)
              abasin(ib) = abasin(ib) * (6.37122e3**2) 
 3116       continue
  
c             Write results, compare to Unesco data

            write (iutab,3118) (cbasin(1,ib), nint(abasin(ib)),
     *                          rbasin(ib),   cbasin(2,ib), ib=1,nbasin)
 3118       format(
     *      /'Annual mean runoff+drainage (mm/yr):'
     *      / 32x,' ',' Area,sq km',3x,'   Model',3x,'  UNESCO'
     *      /(a32,':',         i11 ,3x,     f8.1 ,3x,    4x,a5))

          endif
c----

        else if (curf.eq.'DRARAT') then

          call readfiel2 ('DRAIN   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('RUNOFF  ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 312 i=1,nlon*nlat
            if (abs(arrza(i)+arrzb(i)).gt.1.e-10) then
              arr(i) = arrza(i) / (arrza(i)+arrzb(i))
            else
              arr(i) = 0.
            endif
  312     continue
          cunits = ' '

        else if (curf.eq.'SNOWT') then

          call readfiel2 ('SNOWF   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('SNOWH   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 314 i=1,nlon*nlat
            arr(i) = arrza(i)*arrzb(i)
  314     continue
          cunits = 'm'

        else if (curf.eq.'PRECIPA') then

          zscale = 365.

          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          if (iferr.ne.0) then
            iferr = 0
            call readfiel2 ('PRECL   ', iper, ifile, 
     *                      level,arrza,imap,cunits,nlon,nlat,iferr)
            call readfiel2 ('PRECC   ', iper, ifile, 
     *                      level,arrzb,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arrza(i) = arrza(i) + arrzb(i)
            enddo
          endif
          do i=1,nlon*nlat
            arr(i) = arrza(i)*zscale
          enddo
          cunits = 'mm/year'

        else if (curf.eq.'AVAPA') then

          zscale = 365.

          call readfiel2 ('AVAP    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          if (iferr.ne.0) then
            iferr = 0
            call readfiel2 ('QFLR    ', iper, ifile, 
     *                      level,arrza,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arrza(i) = (arrza(i)/2.5104e6) * 86400.
            enddo
          endif
          do i=1,nlon*nlat
            arr(i) = arrza(i)*zscale
          enddo
          cunits = 'mm/year'

        else if (curf(1:3).eq.'PME') then

          zscale = 1.
          if (curf(4:4).eq.'A') zscale = 365.

          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          if (iferr.ne.0) then
            iferr = 0
            call readfiel2 ('PRECL   ', iper, ifile, 
     *                      level,arrza,imap,cunits,nlon,nlat,iferr)
            call readfiel2 ('PRECC   ', iper, ifile, 
     *                      level,arrzb,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arrza(i) = arrza(i) + arrzb(i)
            enddo
          endif

          call readfiel2 ('AVAP    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          if (iferr.ne.0) then
            iferr = 0
            call readfiel2 ('QFLR    ', iper, ifile, 
     *                      level,arrzb,imap,cunits,nlon,nlat,iferr)
            do i=1,nlon*nlat
              arrzb(i) = (arrzb(i)/2.5104e6) * 86400.
            enddo
          endif
          do i=1,nlon*nlat
c           if (imap(i).ge.1) then           ! (0=ocn,1=land,2=icesheet)
              arr(i) = (arrza(i)-arrzb(i))*zscale
              if (curf(4:4).eq.'A' .and. imap(i).eq.1) then
                arr(i) = max (arr(i), -0.4)
              endif
c           else
c             set to null over ocean
c             arr(i) = 999.
c           endif
          enddo
          cunits = 'mm/day'
          if (curf(4:4).eq.'A') cunits = 'mm/year'

        else if (curf.eq.'PMEMR') then

          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('AVAP    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('RUNOFF  ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('DRAIN   ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do 315 i=1,nlon*nlat
c           if (imap(i).ge.1) then           ! (0=ocn,1=land,2=icesheet)
              arr(i) = (arrza(i)-arrzb(i)-arrzc(i)-arrzd(i)) * .1 * 365.
c           else
c             set to null over ocean
c             arr(i) = 999.
c           endif
  315     continue
          cunits = 'cm/yr'

        else if (curf.eq.'PRECIPI') then

          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arr,imap,cunits,nlon,nlat,iferr)
          do i=1,nlon*nlat
            if (imap(i).eq.2) then           ! (0=ocn,1=land,2=icesheet)
              arr(i) = arr(i) * .1 * 365.
            else
c             set to null over ocean
              arr(i) = 999.
            endif
          enddo
          cunits = 'cm/yr'

        else if (lcurf.gt.2 .and. curf(lcurf-1:lcurf).eq.'_K') then

          ctmpnam = curf(1:lcurf-2)
          call readfiel2 (ctmpnam, iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          if (cunits.eq.'@S@o@N@C') then
            do 316 i=1,nlon*nlat
              arr(i) = arrza(i) + 273.16
  316       continue
            cunits = '@S@o@N@K'
          endif

        else if (curf.eq.'WETA1') then

          call readfiel2 ('WET1    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE1   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 317 i=1,nlon*nlat
            arr(i) = arrza(i)*(1.-arrzb(i)) + arrzb(i)
  317     continue

        else if (curf.eq.'WETA3') then

          call readfiel2 ('WET1    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE1   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET2    ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE2   ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET3    ', iper, ifile, 
     *                    level,arrze,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE3   ', iper, ifile, 
     *                    level,arrzf,imap,cunits,nlon,nlat,iferr)

          hice1 = .05
          hice2 = .10
c Even though 3rd layer is 20 cm thick, use 15 cm for mean over to 30 cm
          hice3 = .15
          hicet = hice1 + hice2 + hice3
          do 318 i=1,nlon*nlat
            arr(i) = ( hice1 * (arrza(i)*(1.-arrzb(i)) + arrzb(i))
     *               + hice2 * (arrzc(i)*(1.-arrzd(i)) + arrzd(i))
     *               + hice3 * (arrze(i)*(1.-arrzf(i)) + arrzf(i))
     *               ) / hicet
  318     continue

        else if (curf.eq.'WETALL') then

          call readfiel2 ('WET1    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE1   ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET2    ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE2   ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET3    ', iper, ifile, 
     *                    level,arrze,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE3   ', iper, ifile, 
     *                    level,arrzf,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET4    ', iper, ifile, 
     *                    level,arrzg,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE4   ', iper, ifile, 
     *                    level,arrzh,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET5    ', iper, ifile, 
     *                    level,arrzi,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE5   ', iper, ifile, 
     *                    level,arrzj,imap,cunits,nlon,nlat,iferr)

          call readfiel2 ('WET6    ', iper, ifile, 
     *                    level,arrzk,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('WICE6   ', iper, ifile, 
     *                    level,arrzl,imap,cunits,nlon,nlat,iferr)

          hice1 = .05
          hice2 = .10
          hice3 = .20
          hice4 = .20
          hice5 = .20
          hice6 = .20
          hicet = hice1 + hice2 + hice3 + hice4 + hice5 + hice6
          do i=1,nlon*nlat
            arr(i) = ( hice1 * (arrza(i)*(1.-arrzb(i)) + arrzb(i))
     *               + hice2 * (arrzc(i)*(1.-arrzd(i)) + arrzd(i))
     *               + hice3 * (arrze(i)*(1.-arrzf(i)) + arrzf(i))
     *               + hice4 * (arrzg(i)*(1.-arrzh(i)) + arrzh(i))
     *               + hice5 * (arrzi(i)*(1.-arrzj(i)) + arrzj(i))
     *               + hice6 * (arrzk(i)*(1.-arrzl(i)) + arrzl(i))
     *               ) / hicet
          enddo

        else if (curf.eq.'CURLTAU') then

          call readfiel2 ('TAUX    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('TAUY    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          radius = 6.37122e6
          dlon = 2.*pi/nlon
          dlat = pi/nlat
          do 319 j=1,nlat
            jm = max(j-1,1)
            jp = min(j+1,nlat)
            cm = cos(-0.5*pi + pi*float(j-1)/nlat)
            cp = cos(-0.5*pi + pi*float(j  )/nlat)
          do 319 i=1,nlon
            im = mod(i-2+nlon,nlon) + 1
            ip = mod(i,nlon) + 1
            m  = i  + nlon*(j -1)
            m1 = ip + nlon*(j -1)
            m2 = i  + nlon*(jp-1)
            m3 = im + nlon*(j -1)
            m4 = i  + nlon*(jm-1)
            arr(m) =
     *        (
     *            ( (arrzb(m1)+arrzb(m))    - (arrzb(m3)+arrzb(m))   )
     *            *0.5*dlat
     *          + (-(arrza(m2)+arrza(m))*cp + (arrza(m4)+arrza(m))*cm)
     *            *0.5*dlon
     *        )
     *        / (radius*0.5*(cm+cp)*dlat*dlon)
            arr(m) = arr(m) * 0.1 * 1.e9
  319     continue
c         Fudge northernmost latitude band to avoid NP difficulties
          do 320 m = nlon*(nlat-1)+1, nlon*nlat
            arr(m) = arr(m-nlon)
  320     continue
          cunits = '1e9 d/c3'


        else if (curf.eq.'SURFLX') then

          call readfiel2 ('FRSA    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('FRLA    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('HFLR    ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('QFLR    ', iper, ifile, 
     *                    level,arrzd,imap,cunits,nlon,nlat,iferr)
          do 330 i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i) - arrzc(i) - arrzd(i)
  330     continue
          cunits = 'W/m@S@2@N@'


        else if (curf.eq.'DTOPOG') then

          call readfiel2 ('TOPOG   ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('TOPOGUN  ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 331 i=1,nlon*nlat
            arr(i) = arrza(i) - arrzb(i)
  331     continue


        else if (curf.eq.'ICEH') then

          call readfiel2 ('ICEH    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
          call readfiel2 ('ICEF    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
          do 332 i=1,nlon*nlat
            if (arrzb(i).ge.0.1) then
              arr(i) = arrza(i)
            else
c             arr(i) = -0.5
              arr(i) =  0.
            endif
  332     continue
          cunits = 'm'


        else if (curf.eq.'QTRANS') then

          call readfiel2 ('QFLUX    ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          radius = 6.37122e6
          qtrans(1) = 0.
          do j=1,nlat
            zla = -0.5*pi + pi*float(j-1)/nlat
            zlb = -0.5*pi + pi*float(j  )/nlat
            zarea = (2.*pi/nlon) * (sin(zlb)-sin(zla)) * (radius**2)

            qtrans(j+1) = qtrans(j)
            do i=1,nlon
              n = i + nlon*(j-1)
              qtrans(j+1) = qtrans(j+1) - arrza(n)*zarea
            enddo

c           Dumbly copy the zonal total transport to 2-D plot array,
c           changing units from watts to pedawatts. Latitudes of
c           plot array are shifted 1/2 a grid box southward from true
c           transport locations (eg, plot's # nlat = transport at NP)

            do i=1,nlon
              n = i + nlon*(j-1)
c             if (imap(n).eq.0) then
                arr(n) = qtrans(j+1)*1.e-15
c             else
c               arr(n) = 0.
c             endif
            enddo
          enddo
          cunits = '10@S@15@N@ W'

        else if (curf.eq.'QTRANS2') then

          call readfiel2 ('TS      ', 0, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)

          radius = 6.37122e6
          qtrans(1) = 0.
          do j=1,nlat
            jp1 = min (j+1,nlat)
            zlat = -0.5*pi + pi*float(j-1)/nlat
            zdx = (2.*pi/nlon) * cos(zlat) * radius 
            zdy = (pi/nlat)*radius

            zf = 0.
            zfp1 = 0.
            do i=1,nlon
              n = i + nlon*(j-1)
              np1 = i + nlon*(jp1-1)
              if (imap(n).eq.0) zf = zf + 1.
              if (imap(np1).eq.0) zfp1 = zfp1 + 1.
            enddo
            zf = 0.5*(zf+zfp1)/nlon

 
          if (zf.le.0.75) then
            zfaco = 1.
          else
            zfaco = 1. - .9 * (zf-.75)/.25
          endif
 
c         Latitude dependence to have max transport at ~20 deg N/S
 
          zl = abs(zlat)*180./pi
          if (zl.le.20.) then
            zfacl = 1.
          else if (zl.le.30.) then
            zfacl = 1. - .7 * (zl-20.)/10.
          else
            zfacl = .3
          endif

          coefstd = 2.0e13   !  (W K-1)
          qfactor = level ! 1,2,...
          zcoef = coefstd * qfactor * zfaco * zfacl

            qtrans(j+1) = 0.
            do i=1,nlon
              n = i + nlon*(j-1)
              np1 = i + nlon*(jp1-1)
              if (imap(n).eq.0 .and. imap(np1).eq.0) 
     *          qtrans(j+1) = qtrans(j+1)
     *                      + zcoef*zdx*(arrza(n) - arrza(np1))/zdy
            enddo

c           Dumbly copy the zonal total transport to 2-D plot array,
c           changing units from watts to pedawatts. Latitudes of
c           plot array are shifted 1/2 a grid box southward from true
c           transport locations (eg, plot's # nlat = transport at NP)

            do i=1,nlon
              n = i + nlon*(j-1)
c             if (imap(n).eq.0) then
                arr(n) = qtrans(j+1)*1.e-15
c             else
c               arr(n) = 0.
c             endif
            enddo
          enddo
          cunits = '10@S@15@N@ W'


        else if (curf.eq.'ATRANS') then
 
          call readfiel2 ('SABTP   ', iper, ifile-10, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
 
          call readfiel2 ('FIRTP   ', iper, ifile-10, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
 
          call readfiel2 ('QFLUX    ', iper, ifile, 
     *                    level,arrzc,imap,cunits,nlon,nlat,iferr)
 
          radius = 6.37122e6

c            First calculate global mean heat fluxes 

          zatot = 0.
          zotot = 0.
          zwtot = 0.
          do j=1,nlat
            zla = -0.5*pi + pi*float(j-1)/nlat
            zlb = -0.5*pi + pi*float(j  )/nlat
            zwei = (2.*pi/nlon) * (sin(zlb)-sin(zla))
            do i=1,nlon
              n = i + nlon*(j-1)
              zatot = zatot + (arrza(n)-arrzb(n))*zwei
              zotot = zotot + (arrzc(n))*zwei
              zwtot = zwtot + zwei
            enddo
          enddo
          zatot = zatot/zwtot
          zotot = zotot/zwtot
          write (6,*) ' atrans: zatot (W/m2) = ',zatot
          write (6,*) ' atrans: zotot (W/m2) = ',zotot

c            Now calculate transport, correcting for global mean flx

          atrans(1) = 0.
          do j=1,nlat
            zla = -0.5*pi + pi*float(j-1)/nlat
            zlb = -0.5*pi + pi*float(j  )/nlat
            zarea = (2.*pi/nlon) * (sin(zlb)-sin(zla)) * (radius**2)

            atrans(j+1) = atrans(j)
            do i=1,nlon
              n = i + nlon*(j-1)
              atrans(j+1) = atrans(j+1)
     *                    + (arrza(n)-arrzb(n)+arrzc(n)-zatot-zotot)
     *                      *zarea
            enddo
 
c           Dumbly copy the zonal total transport to 2-D plot array,
c           changing units from watts to pedawatts. Latitudes of
c           plot array are shifted 1/2 a grid box southward from true
c           transport locations (eg, plot's # nlat = transport at NP)
 
            do i=1,nlon
              n = i + nlon*(j-1)
              arr(n) = atrans(j+1)*1.e-15
            enddo

          enddo
          cunits = '10@S@15@N@ W'


        else if (curf.eq.'LTRANS') then          ! latent heat transport
 
          call readfiel2 ('PRECIP  ', iper, ifile, 
     *                    level,arrza,imap,cunits,nlon,nlat,iferr)
 
          call readfiel2 ('AVAP    ', iper, ifile, 
     *                    level,arrzb,imap,cunits,nlon,nlat,iferr)
 
          radius = 6.37122e6

c            First calculate global mean P-E

          zatot = 0.
          zwtot = 0.
          do j=1,nlat
            zla = -0.5*pi + pi*float(j-1)/nlat
            zlb = -0.5*pi + pi*float(j  )/nlat
            zwei = (2.*pi/nlon) * (sin(zlb)-sin(zla))
            do i=1,nlon
              n = i + nlon*(j-1)
              zatot = zatot + (arrza(n)-arrzb(n))*zwei
              zwtot = zwtot + zwei
            enddo
          enddo
          zatot = zatot/zwtot
          write (6,*) ' ltrans: P-E (mm/day) = ',zatot

c            Now calculate latent heat transport, correcting for global
c            mean flux. Factor hvap/86400 converts surface flux from
c            mm/day to W/m2.

          hvap = 2.5104e6
          atrans(1) = 0.         ! use same array as for ATRANS
          do j=1,nlat
            zla = -0.5*pi + pi*float(j-1)/nlat
            zlb = -0.5*pi + pi*float(j  )/nlat
            zarea = (2.*pi/nlon) * (sin(zlb)-sin(zla)) * (radius**2)

            atrans(j+1) = atrans(j)
            do i=1,nlon
              n = i + nlon*(j-1)
              atrans(j+1) = atrans(j+1)
     *                    - (arrza(n)-arrzb(n)-zatot)*hvap/86400.
     *                      *zarea
            enddo
 
c           Dumbly copy the zonal total transport to 2-D plot array,
c           changing units from watts to pedawatts. Latitudes of
c           plot array are shifted 1/2 a grid box southward from true
c           transport locations (eg, plot's # nlat = transport at NP)
 
            do i=1,nlon
              n = i + nlon*(j-1)
              arr(n) = atrans(j+1)*1.e-15
            enddo

          enddo
          cunits = '10@S@15@N@ W'


c-----------------------------
c       "MIN/MAX/RAN" requests
c-----------------------------

        else if (curf(max(1,lcurf-3):lcurf).eq.'_MIN') then

          curfmmr = curf(1:lcurf-4) // '_M'
          call readfiel2 (curfmmr, iper, ifile, 
     *                    1, arr, imap, cunits, nlon, nlat, iferr)

        else if (curf(max(1,lcurf-3):lcurf).eq.'_MAX') then

          curfmmr = curf(1:lcurf-4) // '_M'
          call readfiel2 (curfmmr, iper, ifile, 
     *                    2, arr, imap, cunits, nlon, nlat, iferr)

        else if (curf(max(1,lcurf-3):lcurf).eq.'_RAN') then

          curfmmr = curf(1:lcurf-4) // '_M'
          call readfiel2 (curfmmr, iper, ifile, 
     *                    1, arrza, imap, cunits, nlon, nlat, iferr)
          call readfiel2 (curfmmr, iper, ifile, 
     *                    2, arrzb, imap, cunits, nlon, nlat, iferr)
          do 400 i=1,nlon*nlat
            arr(i) = arrzb(i) - arrza(i)
  400     continue


c-------------------------
c       "Regular" requests
c-------------------------

        else 

          call readfiel2 (curf, iper, ifile, 
     *                    level, arr, imap, cunits, nlon, nlat, iferr)
c         if (iferr.ne.0) then
c           iferr = 0
c           call readfiel2 (curf, iper, ifile+50,               ! stage3
c    *                      level,arr,imap,cunits,nlon,nlat,iferr)
c         endif

c------------
        endif
c------------

c          Accumulate multi-file average in arrin, and save single-file
c          result in arrsd if standard deviations requested

        znum = ifile2-ifile1+1
        do 1002 i=1,nlon*nlat
          arrin(i) = arrin(i) + arr(i)/znum
 1002   continue

        if (ifsdev .and. ifilin.lt.0) then
          do 1004 i=1,nlon*nlat
            arrsd(i,ifile-ifile1+1) = arr(i)
 1004     continue
        endif

c=============
 1000 continue
c=============

c        After reading all files, compute multi-file standard deviations

      if (ifsdev .and. ifilin.lt.0) then
        call zero (arrtmp, nlon*nlat)
        do 2000 ifile = ifile1,ifile2
          do 2002 i=1,nlon*nlat
            arrtmp(i)= arrtmp(i) + (arrsd(i,ifile-ifile1+1)-arrin(i))**2
 2002     continue
 2000   continue
        do 2100 i=1,nlon*nlat
          arrin(i) = sqrt ( arrtmp(i)/(ifile2-ifile1+1) )
 2100   continue
      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine readfiel2 (curfin, iperin, ifile, 
     *                      level, arrav, imap, cunits, nlon,nlat,iferr)

c        Reads a data record into array arr for field curf in the 
c        current history file. If history file changes, first calls
c        readfile to access it. If period changes, first reads "FIELDS"
c        header record.

c        If file has different resolution than primary 
c        one, convert arr using setmap/gtol.

c        Changes scale for particular fields (to mm/day, deg C, etc)

#include "convcom"
#include "convnetcom"
#include "${NI}/netcdf.inc"

      character curfin*(*), curf*8, cunits*(*) , ch*80
      dimension arrav(parr), arr(parr), imap(parr)
      character cmon(12)*3
      save cmon
      data cmon /'JAN','FEB','MAR','APR','MAY','JUN',
     *           'JUL','AUG','SEP','OCT','NOV','DEC'/
      dimension ndayp(12), ndayp0(12), ndayp126(12)
      data ndayp    /31,28,31,30,31,30,31,31,30,31,30,31/
c777  data ndayp0   /31,28,31,30,31,30,31,31,30,31,30,31/  ! modern
c777  data ndayp126 /34,31,32,30,29,27,28,28,28,32,32,34/  ! 126 ka
      data ndayp0   /30,31,30,31,31,30,31,30,31,31,28,31/  ! modern
      data ndayp126 /30,29,27,28,28,28,32,32,34,34,31,32/  ! 126 ka

      save ifileprev, nlonprev, nlatprev
      data ifileprev, nlonprev, nlatprev /0,0,0/

      save nlonsetprev, nlatsetprev
      data nlonsetprev, nlatsetprev /0,0/

      curf = curfin

c        If new hist file, open it, read imap.
c        If not new file, still reset nlon,nlat to previous since they
c        could have been changed in previous call if dirrerent from
c        primary resolution.

      if (ifile.ne.ifileprev) then
         if (ifileprev.ne.0) rcode = nf_close (ncid)
         call readfile (ifile, imap, nlon, nlat)
         ifileprev = ifile
         nlonprev = nlon
         nlatprev = nlat
      else
         nlon = nlonprev
         nlat = nlatprev 
      endif

c        Loop over periods if annual mean requested,
c        or convert single months to 3 monthly mean if if3mon set

      if ( curf(1:3).eq.'SLP' .or. curf(1:3).eq.'SAT' .or.
     *     curf(1:3).eq.'PRC' ) then
        ndatex = 12
      else
        ndatex = ndate
      endif
      if (iperin.eq.0 .or. iperin.gt.ndatex) then
        ipera = 1
        iperb = ndatex
      else
        ipera = iperin
        iperb = iperin
        if (if3mon .and. curf(1:5).ne.'ISCCP') then
          ipera = ipera - 1
          iperb = iperb + 1
        endif
      endif

      call zero (arrav, nlon*nlat)
      zweitot = 0.

c===============================
      do 500 iperc = ipera,iperb
c===============================

      if (if3mon) then
        iper = mod (iperc-1+12, 12) + 1
      else
        iper = iperc
      endif
      iper = max (1, min (iper, ndate))

      if ( curf(1:3).eq.'SLP' .or. curf(1:3).eq.'SAT' .or.
     *     curf(1:3).eq.'PRC' ) then
        curf = curf(1:3) // cmon(max(1,min(12,iper)))
      endif

c       Get number of dimensions

      rcode = nf_inq_varid (ncid, curf, varid)
      rcode = nf_inq_varndims (ncid, varid, ndims)

c        Read data slice

      if (ndims.eq.4) then
c       write (6,*) 'ndims=',ndims, '  level=',level,'  nlev=',nlev
        ilev = max (1, min (level,nlev))
        starta(3) = ilev
        counta(3) = 1   
        starta(4) = iper
        counta(4) = 1   
        rcode = nf_get_vara_real (ncid, varid, starta, counta, var4)
      else
        start(3) = iper
        count(3) = 1   
        rcode = nf_get_vara_real (ncid, varid, start, count, var4)
      endif
      if (rcode.ne.nf_noerr) then
c       write (6,'(a)') nf_strerror(rcode)
c       write (6,'(3a,2i6)') 'curf=', curf,'  ipera,b=', ipera, iperb
        iferr = 1
      endif
      do i=1,nlon*nlat
        arr(i) = var4(i)
      enddo

c        Set units 

      rcode = nf_get_att_text (ncid, varid, 'units', cunits)
      do i=len(cunits),1,-1
        if (cunits(i:i).eq.char(0)) cunits(i:i) = ' '
      enddo

c     write (*,'(a,a)') 'cunits=',cunits	
c     write (*,'(a,i10)') 'ndims=',ndims
c     write (*,*) 'start=',start
c     write (*,*) 'count=',count
c     write (*,'(180i1)') (nint(arr(i)),i=1,nlon*nlat)

c        Convert lsx mask to 0=ocean/seaice,1=land,2=icesheet (for gf)

      if (curf.eq.'LMASK') then
         do 110 i=1,nlon*nlat
            if (nint(arr(i)).ge.3) arr(i) = 0.
  110    continue
      endif

c           Change scale of some fields

      if ( curf(1:8).eq.'PRECL   '.or.
     *     curf(1:8).eq.'PRECC   '.or.
     *     curf(1:8).eq.'PRECL_O '.or.
     *     curf(1:8).eq.'PRECC_O '.or.
     *     curf(1:8).eq.'PRECL_H '.or.
     *     curf(1:8).eq.'PRECC_H '.or.
     *    (curf(1:8).eq.'RAINF   '.and. clabel(1:3).eq.'CCM') .or.
     *    (curf(1:8).eq.'SNOWF   '.and. clabel(1:3).eq.'CCM') .or.
     *     curf(1:8).eq.'RAINF_O '.or.
     *     curf(1:8).eq.'SNOWF_O '.or.
     *     curf(1:8).eq.'RAINF_H '.or.
     *     curf(1:8).eq.'SNOWF_H '.or.
     *     curf(1:8).eq.'PRECIP  '.or.
     *     curf(1:8).eq.'TRANSP  '.or.
     *     curf(1:8).eq.'RUNOFF  '.or.
     *     curf(1:8).eq.'RUNOFT  '.or.
     *     curf(1:8).eq.'DRAIN   '.or.
     *     curf(1:8).eq.'AVAP    '.or.
     *     curf(1:8).eq.'INTVAP  '.or.
     *     curf(1:8).eq.'SURVAP  '.or.
     *     curf(1:8).eq.'FOGRAT  '.or.
     *     curf(1:8).eq.'PMEOCN  '
     *     ) then

        do 300 i=1,nlon*nlat
          arr(i) = arr(i) * 8.64E7
  300   continue
        cunits = 'mm/day'

      else if (curf(1:8).eq.'PS      '.or.curf(1:8).eq.'PSLEV   ') then

        do 304 i=1,nlon*nlat
          arr(i) = arr(i) * .01
  304   continue
        cunits = 'mb'

      else if (curf(1:8).eq.'SLP     ') then

        cunits = 'mb'

      else if (curf(1:8).eq.'PRC     ') then

        cunits = 'mm/day'

      else if (curf(1:8).eq.'ISCCP08 ') then

        do 305 i=1,nlon*nlat
          arr(i) = arr(i) * .01
  305   continue
        cunits = ' '

      else if ( curf(1:8).eq.'T       '.or.
     *          curf(1:8).eq.'TA      '.or.curf(1:8).eq.'TA_M    '.or.
     *          curf(1:8).eq.'TS      '.or.curf(1:8).eq.'TS_M    '.or. 
     *          curf(1:8).eq.'TS2     '.or.curf(1:8).eq.'TS2_M   '.or. 
     *          curf(1:8).eq.'TS10    '.or.curf(1:8).eq.'TOCEAN  '.or.
     *          curf(1:8).eq.'T_CDATA '.or.
     *          curf(1:8).eq.'SAT     '.or.
     *          curf(1:8).eq.'T_CRUTCH'.or.
     *          curf(1:8).eq.'T_CRUCD '
     *        ) then
        do 306 i=1,nlon*nlat
          arr(i) = arr(i) - 273.16
  306   continue
c       cunits = '@S@o@N@C'
        cunits = 'deg C'

      else if (curf(1:8).eq.'Z200    '  .or. 
     *         curf(1:8).eq.'Z500    '  .or. 
     *         curf(1:8).eq.'Z850    ') then
        do 307 i=1,nlon*nlat
          arr(i) = 0.1*arr(i)
  307   continue
        cunits = 'dam'

      else if (curf(1:8).eq.'WPUD   '  .or. 
     *         curf(1:8).eq.'WIPUD  ') then
        do 308 i=1,nlon*nlat
          arr(i) = 1000.*arr(i)
  308   continue
        cunits = 'mm'

      endif

      if (cunits.eq.'K'.or.cunits.eq.'k') cunits = '@S@o@N@K'
      if (cunits.eq.'M'.or.cunits.eq.'m') cunits = 'meters'
      if (cunits.eq.'FRACTION'.or.cunits.eq.'fraction') cunits = ' '
      if (cunits.eq.'FLAG'.or.cunits.eq.'flag') cunits = ' '
      if (cunits.eq.'M/S') cunits = 'm/s'
      if (cunits.eq.'W/M@S@2@N@') cunits = 'W/m@S@2@N@'

c        Accumulate multi-period average in arryr

c     if ( (ipera.eq.1.and.iperb.eq.12) .or. if3mon) then
c       if (icalendar.eq.126) then
c         zwei = ndayp126(iper)
c       else
c         zwei = ndayp0(iper)
c       endif
c     else
c       zwei = 1.
c     endif

      ch = file(ifile)
      lch = lenchr(ch)
      if (ch(lch-8:lch).eq.'ISCCP_GEN' .or. 
     *    ch(lch-7:lch).eq.'HISTSHEA') then
        zwei = 1.
      else
        zwei = dateb(iper)-datea(iper)  ! 777777
c       zwei = ndayp(iper)              ! 777777
      endif

      do 400 i=1,nlon*nlat
        arrav(i) = arrav(i) + arr(i)*zwei
  400 continue

      zweitot = zweitot + zwei

c=============
  500 continue
c=============

      do i=1,nlon*nlat
        arrav(i) = arrav(i)/zweitot
      enddo

c        Convert to primary resolution if necessary

c     write (6,'(a,2i6)') file(ifile)(1:lenchr(file(ifile))), nlon,nlat
c     write (6,'(2i6)') nlonsetprev, nlatsetprev
      if ( (nlon.ne.$nlona      .or. nlat.ne.$nlata) 
c    *      .and. (nlon.ne.nlonsetprev .or. nlat.ne.nlatsetprev) 
     *    ) then
         if (nlon.lt.$nlona) then
           call setmap (nlon, nlat, $nlona, $nlata, .false.)
           call gtol (arrav, arrtmp, 0, nlon, nlat, $nlona, $nlata)
         else
           call setmap ($nlona, $nlata, nlon, nlat, .false.)
           call ltog (arrav, arrtmp, 0, $nlona, $nlata, nlon, nlat)
         endif
c        nlonsetprev = nlon
c        nlatsetprev = nlat
         nlon = $nlona
         nlat = $nlata
         do 600 i = 1, nlon*nlat
            arrav(i) = arrtmp(i)
  600    continue
      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine readfielccc (curfin, iper, ifile, 
     *                        level, arr, imap, cunits, nlon,nlat,iferr)

c     Reads CCC (GCM) monthly-mean files, returns requested field in arr
c     (like combined readfile/readfiel/readfiel2). Field name is
c     in curfin: gt=skin temp, ps=surface pressure, gc=land/ocean
c     mask, to=topography, pr=precipitation, te=lowest-level air temp,
c     qe=lowest-level specific humidity (units given below).

#include "convcom"

      character curfin*(*), cunits*(*) 
      dimension arr(parr), imap(parr)

      dimension arrccc(96,48), arrccci(97,48), iheadc(8), imonc(12),
     *          ibufstat(1000)
      character cfilec*200, cfc*8, cav1*4, cav2*4
      logical firstcccmap, ifexist
      data firstcccmap /.true./

      dimension eta10(10)
      data eta10 /
     *  .012, .038, .088, .160, .265,
     *  .430, .633, .803, .915, .980 /

      iferr = 0

      cfc = curfin(1:2)
      call lower (cfc)
      if (cfc.eq.'gt' .or. cfc.eq.'ps' .or. cfc.eq.'gc' .or.
     *    cfc.eq.'to' .or. cfc.eq.'pr') then
        nlev = 1
        level = 1
        sig(1) = 1.
      else
        nlev = 10
        if (level.eq.0) level = nlev       ! request 0 gets lowest level
        level =  max (1, min (level, nlev))
        do k=1,nlev
          sig(k) = eta10(k)
        enddo
      endif
      ndate = 12

      call zero (arrccc, 96*48)
      kount = 0

c     set (0/1) flags imonc(1:12) indicating requested months
      imonmax = 0
      if (iper.eq.0 .or. iper.gt.12) then
        ipera = 1
        iperb = 12
      else
        ipera = iper
        iperb = iper
        if (if3mon) then
          ipera = ipera - 1
          iperb = iperb + 1
        endif
      endif
      do m = 1,12
        imonc(m) = 0
      enddo
      do m = ipera,iperb
        ipc = mod (m-1+12, 12) + 1
        imonc(ipc) = 1
        imonmax = max (imonmax,ipc)
      enddo

c     set requested years (files)
      if (ifile.ge.0) then
        ifile1 = ifile
        ifile2 = ifile
      else
        n = (-ifile-1)/10
        ifile1 = 1 + n*10
        ifile2 = -ifile
      endif

c     loop over requested years (files) 
      do ifc = ifile1, ifile2
        cfilec = file(ifc)(1:lenchr(file(ifc))) //
     *            '_' // cfc(1:2) // '.mon'
        inquire (file=cfilec, exist=ifexist)
        if (.not.ifexist) then
          write (6,'(/2a)') 
     *      '*** Error (dopanel): file not found: ',
     *      cfilec(1:lenchr(cfilec))
          stop
        endif
c       test if file to be opened is migrated
        do j=1,1000
          ibufstat(j)=0
        enddo
        ier = stat (cfilec, ibufstat)
        if (ibufstat(19).eq.0) then
          write (6,'(/2a)')
     *      '*** nb (dopanel): file is migrated:',
     *      cfilec(1:lenchr(cfilec))
          ier = flush(6)
        endif

        open (70,file=cfilec, status='old', form='formatted')

c       loop over months up to max month requested
        do m=1,imonmax
c         loop over levels
          do k=1,level
            read (70,'(1x,a4,i10,1x,a4,5i10)') (iheadc(i),i=1,8)
            read (70,'(1p6e12.5)')
     *        ((arrccci(i,j),i=1,iheadc(5)),j=1,iheadc(6))
            if (imonc(m).eq.1 .and. ! want requested months only
     *          k.eq.level) then    ! want requested level  only
              do j=1,48
                do i=1,96
                  arrccc(i,j) = arrccc(i,j) + arrccci(i,j)
                enddo
              enddo
              kount = kount + 1
            endif
          enddo
        enddo

        close (70)
      enddo

      do j=1,48
        do i=1,96
          arrccc(i,j) = arrccc(i,j)/kount
        enddo
      enddo

c        Convert to primary resolution if necessary

      if (96.ne.$nlona .or. 48.ne.$nlata) then
        if (96.lt.$nlona) then
          call setmap (96, 48, $nlona, $nlata, .true.)
          call gtol (arrccc, arr, 0, 96, 48, $nlona, $nlata)
        else
          call setmap ($nlona, $nlata, 96, 48, .true.)
          call ltog (arrccc, arr, 0, $nlona, $nlata, 96, 48)
        endif
      else
        call scopy (96*48, arrccc, 1, arr, 1)
      endif
      nlon = $nlona
      nlat = $nlata

      zshif = 0.
      zscal = 1.
      if (cfc.eq.'gt' .or. cfc.eq.'te') then
        cunits = '@S@o@N@C'
        zshif = 273.16
      else if (cfc.eq.'qe') then
        cunits = 'kg/kg'
      else if (cfc.eq.'ue' .or. cfc.eq.'ve') then
        cunits = 'm/s'
      else if (cfc.eq.'ps') then
        cunits = 'mb'
      else if (cfc.eq.'pr') then
        cunits = 'mm/day'
      else if (cfc.eq.'gc') then
        cunits = 'flag'
c       convert from ccc mask to gf mask:
        do i=1,${nlona}*${nlata}
          if (nint(arr(i)).eq.-1) then      !ice sheet or land
            arr(i) = 1.
          else if (nint(arr(i)).ge.0) then  !ocean or seaice
            arr(i) = 0.
          endif
          if (firstcccmap) imap(i) = nint(arr(i))
        enddo
        firstcccmap = .false.
      else if (cfc.eq.'to') then
        cunits = 'm'
        zscal = 9.80616
      endif
      do i=1, $nlona * $nlata
        arr(i) = (arr(i) - zshif)/zscal
      enddo

      n1 = lenchr(file(ifile1))
      cav1 = file(ifile1)(n1-3:n1)
      n2 = lenchr(file(ifile2))
      cav2 = file(ifile2)(n2-3:n2)
      runtitle = 'CCCGCM' // cav1 // '-' // cav2

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine getcru (arr, cunits, cvar, ifreg, xlon, xlat, 
     *                   nlon, nlat, iper, if3mon, znulp)

c        Reads a global CRU climatology file for field specified by
c        cvar, for month(s) specified by iper.
c        Tiles/interps to requested grid (global if ifreg=0, regional
c        if ifreg=1 given by xlon, xlat). nlon and nlat are requested
c        grid size.
c        Returns field in arr, units in cunits.

      dimension arr(nlon,nlat), xlon(nlon,nlat), xlat(nlon,nlat)
      character*(*) cunits, cvar
      logical if3mon

      dimension imonc(12)
      character*80 crufile
      parameter (nloncru = 720, nlatcru=360)  ! cru grid (0.5 deg)
      dimension arrcru(nloncru,nlatcru), iarrin(nloncru,nlatcru),
     *          aloncru(nloncru), alatcru(nlatcru)
      logical firstcru
      save aloncru, alatcru, firstcru
      data firstcru /.true./
      data iucru /77/

      parameter (pi=3.14159265358979)

      if (firstcru) then
        do j=1,nlatcru
          alatcru(j) = -0.5*pi + pi*(j-.5)/nlatcru
        enddo
        do i=1,nloncru
          aloncru(i) = 2.*pi*(i-.5)/nloncru
        enddo
        firstcru = .false.
      endif

      do j=1,nlatcru
        do i=1,nloncru
          arrcru(i,j) = 0.
        enddo
      enddo
      kount = 0

c        set (0/1) flags imonc(1:12) indicating requested months

      imonmax = 0
      if (iper.eq.0 .or. iper.gt.12) then
        ipera = 1
        iperb = 12
      else
        ipera = iper
        iperb = iper
        if (if3mon) then
          ipera = ipera - 1
          iperb = iperb + 1
        endif
      endif
      do m = 1,12
        imonc(m) = 0
      enddo
      do m = ipera,iperb
        ipc = mod (m-1+12, 12) + 1
        imonc(ipc) = 1
        imonmax = max (imonmax,ipc)
      enddo

      zshift = 0.
      zscale = 1.
      if (cvar.eq.'TOBS') then
        crufile = '/svarch/pollard/MISC/Cru/ctmp8190.dat'
        zscale = 10.
        cunits = '@S@o@N@C'
      else if (cvar.eq.'POBS') then
        crufile = '/svarch/pollard/MISC/Cru/cpre8190.dat'
        zscale = 10.
        cunits = 'mm/day'
      else if (cvar.eq.'COBS') then
        crufile = '/svarch/pollard/MISC/Cru/ccld8190.dat'
        zscale = 100.
        cunits = 'fraction'
      else
        write (6,*) '*** Error (getcru): unknown field name ', cvar
        stop
      endif

      open (iucru, file=crufile, form='formatted', status='old')
      read (iucru,'(/)')           ! 2 header records

c       loop over months up to max month requested
      do m=1,imonmax
        do j=nlatcru,1,-1        ! cru records run NP to SP 
          read (iucru,'(720i5)') (iarrin(i,j),i=1,nloncru)
        enddo
        if (imonc(m).eq.1) then  ! want requested months only
          do j=1,nlatcru
            do i=1,nloncru
              arrcru(i,j) = arrcru(i,j) + iarrin(i,j)
            enddo
          enddo
          kount = kount + 1
        endif
      enddo
      close (iucru)

      do j=1,nlatcru
        do i=1,nloncru
c         cru "missing" value is -9999 (handled by ltog2 below)
          if (nint(arrcru(i,j)).eq.-9999) then
            arrcru(i,j) = -9999.
          else
            arrcru(i,j) = ((arrcru(i,j)/kount) - zshift ) / zscale
          endif
        enddo
      enddo
      

c        Convert to requested resolution if necessary

      if (ifreg.eq.0) then

c          Global grid

        call setmap (nlon, nlat, nloncru, nlatcru, .false.)
        call ltog2 (arrcru, arr, 0, nlon, nlat, nloncru, nlatcru,-9999.)

      else

c          Regional Model grid
 
c       call interph (arr, xlon, xlat, nlon, nlat, 
c    *                arrcru, aloncru, alatcru, nloncru, nlatcru)
 
      endif

c       Reset missing value (used in zonmean). -200 used to not
c       skew the anorm scaling too much for x,y plots.

      znulp = -200.
      do j=1,nlat
        do i=1,nlon
          if (nint(arr(i,j)).eq.-9999) arr(i,j) = znulp
        enddo
      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine dopanel (ipan, npanel, ifdif,
     *                    ifile, iper, level, ipole, 
     *                    nname, cname, cexpr, contour,
     *                    nlon, nlat)

c        Reads record(s) for particular field(s) and period from the
c        current history file into arr, and writes a block of records
c        for one panel and one period to the gf-input file.

c        The resulting gf-input block consists of 4 header lines,
c        followed by nname field blocks consisting of 1 field-intro
c        line, nlat field lines and 1 field-end line. Finally there are
c        5 block-terminal lines. The field-intro line declares an array
c        with that field name and to read the following block of data.
c        The field-end line tells gf to rescale that array back to 
c        original values. The first block-terminal line is
c        "field=<cexpr> #", where cexpr is the user-entered expression,
c        and the remaining 4 block-terminal lines are for the zonal 
c        mean of the last field, to be read into zonfield.

#include "convcom"

      dimension ifile(10), iper(10), level(10), ipole(10), nname(10)
      character cname(10,pname)*8, cexpr(10)*200, 
     *          contour(10,pcon)*200, contmp*1000
      dimension arr(parr), arrdif(parr), iarr(parr), imap(parr),
     *          zonarr(1000,3), zonisot(1000),
     *          arrz1(parr), arrz2(parr), arrz3(parr), arrz4(parr),
     *          arrz5(parr), arrz6(parr),
c for cross:
     *          arrza(parr), arrzb(parr), arrzc(parr), arrzd(parr),
     *          arrze(parr), arrzf(parr), arrzg(parr), arrzh(parr,18)

      character*6 czonarr(1000,3)
      character cform*30, title*100, subtitle*100, subtitle2*100,
     *          cunits*30
      dimension itmp(12), tmp(12)
      character ctmp(12)*8
      equivalence (itmp,tmp,ctmp)
      character*20 setmult, chmult, setper, chper, setfile
      character cnamez(10)*8, cexprz(10)*200, cz*1
      character cmon(12)*3
      character ctmpnam*8, ctmpnam2*8
      character clev*3, chlev*80
 
      character ch1*200
      character runtitsav(10)*80, subtitsav(10)*80,
     *          setpersav(10)*20, cexprprev*200
      character*6 czonarrsav(1000,3,10)
      dimension pindiasav(10), arrsav(parr)
      save runtitsav, subtitsav, setpersav, cexprprev, 
     *     arrsav, czonarrsav, pindiasav, imap
      data cexprprev /' '/

c     for "ascii":
      dimension
     *  xmask_f($nlona,$nlata),
     *  topogun_f($nlona,$nlata),
     *  ts2_f($nlona,$nlata,12),
     *  ts_f($nlona,$nlata,12),
     *  precip_f($nlona,$nlata,12),
     *  pme_f($nlona,$nlata,12),
     *  sdt_f($nlona,$nlata,12),
     *  sdp_f($nlona,$nlata,12),
     *  weta3_f($nlona,$nlata,12),
     *  pslev_f($nlona,$nlata,12),
     *  snowf_f($nlona,$nlata,12),
     *  icef_f($nlona,$nlata,12),
     *  iceh_f($nlona,$nlata,12),
     *  z500_f($nlona,$nlata,12),
     *  u8_f  ($nlona,$nlata,12),     ! level  8, sigma=.251
     *  v8_f  ($nlona,$nlata,12),
     *  u11_f($nlona,$nlata,12),      ! level 11, sigma=.501
     *  v11_f($nlona,$nlata,12),
     *  u15_f($nlona,$nlata,12),      ! level 15, sigma=.866
     *  v15_f($nlona,$nlata,12)
      real icef_f, iceh_f

c for cross:
      parameter (nlatmax=180,nvertmax=18) 
      dimension 
     * tverta(nlatmax,nvertmax), tvertb(nlatmax,nvertmax),
     * qverta(nlatmax,nvertmax), qvertb(nlatmax,nvertmax),
     * rverta(nlatmax,nvertmax), rvertb(nlatmax,nvertmax),
     * cverta(nlatmax,nvertmax), cvertb(nlatmax,nvertmax),
     * uverta(nlatmax,nvertmax), uvertb(nlatmax,nvertmax),
     * wverta(nlatmax,nvertmax), wvertb(nlatmax,nvertmax),
     * sverta(nlatmax,nvertmax),
     * nverta(nlatmax,nvertmax)
      dimension alatout(nlatmax)


c latitude grid for T10 (for cross):
      dimension alatt10(16)
      data alatt10 /
     *  -81.651, -70.835, -59.955, -49.061, -38.161, -27.259,
     *  -16.356,  -5.452,   5.452,  16.356,  27.259,  38.161,
     *   49.061,  59.955,  70.835,  81.651 /

c latitude grid for T31 (for cross):
      dimension alatt31(48)
      data alatt31 /
     *  -1.5212131731, -1.4569823009, -1.3923721142, -1.3276762287,
     *  -1.2629478409, -1.1982037311, -1.1334508412, -1.0686925583,
     *  -1.0039307308, -0.9391664533, -0.8744004155, -0.8096330743,
     *  -0.7448647446, -0.6800956510, -0.6153259588, -0.5505557923,
     *  -0.4857852479, -0.4210144016, -0.3562433151, -0.2914720392,
     *  -0.2267006173, -0.1619290868, -0.0971574813, -0.0323858319,
     *   0.0323858319,  0.0971574813,  0.1619290868,  0.2267006173,
     *   0.2914720392,  0.3562433151,  0.4210144016,  0.4857852479,
     *   0.5505557923,  0.6153259588,  0.6800956510,  0.7448647446,
     *   0.8096330743,  0.8744004155,  0.9391664533,  1.0039307308,
     *   1.0686925583,  1.1334508412,  1.1982037311,  1.2629478409,
     *   1.3276762287,  1.3923721142,  1.4569823009,  1.5212131731
     *   /

c     for storm-track filtered 500 mb sd:
      character cfilea*200, czf*8, czm*8
      dimension zstormt31 (96,48), zstorm(parr)

      character*8 cztmp
      dimension xlondum(1,1), xlatdum(1,1)
      logical ifsdevsav

      parameter (pi=3.14159265358979)
      character cisot*7

      character*8 clabout, cunitsout

c-----------------------------------
c     Statement functions esat, qsat
c-----------------------------------
c
c        Polynomials for svp(t), d(svp)/dt over water and ice are from
c        Lowe(1977),JAM,16,101-103.
c
      PARAMETER (ASAT0 =  6.107799961,
     *           ASAT1 =  4.436518521E-1,
     *           ASAT2 =  1.428945805E-2,
     *           ASAT3 =  2.650648471E-4,
     *           ASAT4 =  3.031240396E-6,
     *           ASAT5 =  2.034080948E-8,
     *           ASAT6 =  6.136820929E-11 )
c
      PARAMETER (BSAT0 =  6.109177956,
     *           BSAT1 =  5.03469897E-1,
     *           BSAT2 =  1.886013408E-2,
     *           BSAT3 =  4.176223716E-4,
     *           BSAT4 =  5.824720280E-6,
     *           BSAT5 =  4.838803174E-8,
     *           BSAT6 =  1.838826904E-10 )
c
c----------
c
c         Statement functions TSATL,TSATI are used below so that Lowe's
c         polyomial for liquid is used if T gt TMELT, or for ice if 
c         T lt TMELT. Also impose range of validity for Lowe's polys.
c
       TSATL(T) = MIN (100., MAX (T-273.16, 0.))
       TSATI(T) = MAX (-60., MIN (T-273.16, 0.))
c
c----------
c
c         Statement function ESAT is svp in N/m**2, with T in deg K. 
c         (100 * Lowe's poly since 1 mb = 100 N/m**2.)
c
      ESAT (T) = 
     *  100.*(
     *    CVMGT (ASAT0, BSAT0, T.GE.273.16)
C
     *    + TSATL(T)*(ASAT1 + TSATL(T)*(ASAT2 + TSATL(T)*(ASAT3
     *    + TSATL(T)*(ASAT4 + TSATL(T)*(ASAT5 + TSATL(T)* ASAT6)))))
C
     *    + TSATI(T)*(BSAT1 + TSATI(T)*(BSAT2 + TSATI(T)*(BSAT3
     *    + TSATI(T)*(BSAT4 + TSATI(T)*(BSAT5 + TSATI(T)* BSAT6)))))
     *  )

c----------
c
c        Statement function QSAT is saturation specific humidity,
c        with svp E and ambient pressure P in N/m**2. Impose an upper
c        limit of 1 to avoid spurious values for very high svp
c        and/or small P.
c
       QSAT (E, P) = .622*E / MAX ( P-(1.-.622)*E, .622*E )
c
c----------

      iferr = 0

c        Top of loop for multiple fields in expressions

      do 100 iname=1,nname(ipan)

c           Strip non-alphanumeric characters from field and expression
c           names for gf, creating temporary names here for writing to
c           data file

         do 20 n=1,10
           cnamez(n) = ' '
           ii = 0
           do 22 i=1,lenchr(cname(n,iname))
             m = ichar(cname(n,iname)(i:i))
             if ( (m.ge.ichar('0').and.m.le.ichar('9')) .or.
     *            (m.ge.ichar('A').and.m.le.ichar('Z')) .or.
     *            (m.ge.ichar('a').and.m.le.ichar('z')) ) then
               ii = ii + 1
               cnamez(n)(ii:ii) = cname(n,iname)(i:i)
             endif
  22       continue

           cexprz(n) = ' '
           ii = 0
           do 24 i=1,lenchr(cexpr(n))
             cz = cexpr(n)(i:i)
             m = ichar(cz)
             if ( (m.ge.ichar('0').and.m.le.ichar('9')) .or.
     *            (m.ge.ichar('A').and.m.le.ichar('Z')) .or.
     *            (m.ge.ichar('a').and.m.le.ichar('z')) 
     *            .or. cz.eq.'(' .or. cz.eq.')' .or. cz.eq.'*'
     *            .or. cz.eq.'/' .or. cz.eq.'%' .or. cz.eq.'+'
     *            .or. cz.eq.'-' .or. cz.eq.'=' .or. cz.eq.'.'
     *            .or. cz.eq.',') then
               ii = ii + 1
               cexprz(n)(ii:ii) = cz
             endif
  24       continue
  20     continue

c           Read field into arr. Loop twice for difference plots
c           (ifdif=1). 

         do 300 iloop = 1,2
           if (ifdif.ne.1) then
             ip = ipan
             if(iloop.eq.2) goto 300
           else
             ip = iloop
           endif

c++++++++++++++++++++++++++++++++++++++++++++++
           if (cname(ip,iname).eq.'CROSS') then
c++++++++++++++++++++++++++++++++++++++++++++++

             if (nlat.eq.16) then
               do j=1,16
                 alatout(j) = alatt10(j)*pi/180.
               enddo
             else if (nlat.eq.48) then
               call scopy (48, alatt31, 1, alatout, 1)
             else
               do j=1,nlat
                 alatout(j) = -0.5*pi + ((j-.5)/nlat)*pi
               enddo
             endif

             call readfiel ('PS      ', iper(ip), ifile(ip), 
     *                          1,arrzc,imap,cunits,nlon,nlat,iferr)
             if (iferr.ne.0) return

             call zero  (tverta, nlatmax*nvertmax)
             call zero  (qverta, nlatmax*nvertmax)
             call zero  (rverta, nlatmax*nvertmax)
             call zero  (cverta, nlatmax*nvertmax)
             call zero  (uverta, nlatmax*nvertmax)
             call zero  (wverta, nlatmax*nvertmax)
             do i=1,nlatmax
               do j=1,nvertmax
                 nverta(i,j) = 0
               enddo
             enddo

             do 3140 ivert=1,nlev
               call readfiel ('Q       ', iper(ip), ifile(ip),
     *                        ivert,arrza,imap,cunits,nlon,nlat,iferr)
               if (iferr.ne.0) return
               call readfiel ('T       ', iper(ip), ifile(ip),
     *                        ivert,arrzb,imap,cunits,nlon,nlat,iferr)
               if (iferr.ne.0) return
               call readfiel ('CLOUD   ', iper(ip), ifile(ip),
     *                        ivert,arrzd,imap,cunits,nlon,nlat,iferr)
               if (iferr.ne.0) return
               call readfiel ('U       ', iper(ip), ifile(ip),
     *                        ivert,arrze,imap,cunits,nlon,nlat,iferr)
               if (iferr.ne.0) return
               call readfiel ('OMEGA   ', iper(ip), ifile(ip),
     *                        ivert,arrzf,imap,cunits,nlon,nlat,iferr)
               if (iferr.ne.0) return
               call readfiel ('RHUMID  ', iper(ip), ifile(ip),
     *                        ivert,arrzg,imap,cunits,nlon,nlat,iferr)
               if (iferr.ne.0) return
               call readfiel ('V       ', iper(ip), ifile(ip),
     *                        ivert,arrzh(1,ivert),imap,cunits,
     *                        nlon,nlat,iferr)
               if (iferr.ne.0) return

               zsig = sig (ivert)
               do 3142 j=1,nlat
                 do 3144 i=1,nlon
                   ii = i + (j-1)*nlon
                   if (imap(ii).ge.0) then                        !all
c                  if (imap(ii).eq.0) then                        !ocean
c                  if (imap(ii).eq.1) then                        !land
                     qverta(j,ivert) = qverta(j,ivert)
     *                                 + arrza(ii)*1.e3
                     tverta(j,ivert) = tverta(j,ivert)
     *                                 + arrzb(ii)
c                    zesat = esat(arrzb(ii))
c                    zmixrat = arrza(ii) / (1.-arrza(ii))
c                    rverta(j,ivert) = rverta(j,ivert)
c    *                                 + (zmixrat/(zmixrat+.622))
c    *                                   * (arrzc(ii)*zsig/zesat)
                     rverta(j,ivert) = rverta(j,ivert)
     *                                 + arrzg(ii)
                     cverta(j,ivert) = cverta(j,ivert)
     *                                 + arrzd(ii)
                     uverta(j,ivert) = uverta(j,ivert)
     *                                 + arrze(ii)
                     wverta(j,ivert) = wverta(j,ivert)
     *                                 + arrzf(ii)*86400.*1.e-2
                     nverta(j,ivert) = nverta(j,ivert) + 1
                   endif
 3144            continue
 3142          continue

               do 3146 j = 1,nlat
                 if (nverta(j,ivert).gt.0) then
                   tverta(j,ivert) = tverta(j,ivert)
     *                                / nverta(j,ivert)
                   qverta(j,ivert) = qverta(j,ivert)
     *                                / nverta(j,ivert)
                   rverta(j,ivert) = rverta(j,ivert)
     *                                / nverta(j,ivert)
                   cverta(j,ivert) = cverta(j,ivert)
     *                                / nverta(j,ivert)
                   uverta(j,ivert) = uverta(j,ivert)
     *                                / nverta(j,ivert)
                   wverta(j,ivert) = wverta(j,ivert)
     *                                / nverta(j,ivert)
                 endif
 3146          continue

               write (6,*) 'done level ',ivert
               ier = flush(6)
 3140        continue

c           Save run title. If difference plot, save field (first loop)
c           or compute difference (second loop).

             if (ifdif.eq.1 .and. iloop.eq.1) then
               runtita = runtitle
               do 3300 ivert=1,nlev
                 do 3320 j=1,nlat
                   tvertb(j,ivert) = tverta(j,ivert)
                   qvertb(j,ivert) = qverta(j,ivert)
                   rvertb(j,ivert) = rverta(j,ivert)
                   cvertb(j,ivert) = cverta(j,ivert)
                   uvertb(j,ivert) = uverta(j,ivert)
                   wvertb(j,ivert) = wverta(j,ivert)
 3320            continue
 3300          continue
               goto 3000
             else if (ifdif.eq.1 .and. iloop.eq.2) then
               runtita = runtitle(1:lenchr(runtitle)) // ' minus '
     *                // runtita
               do 334 ivert=1,nlev
                 do 336 j=1,nlat
                   tverta(j,ivert) = tverta(j,ivert)
     *                                - tvertb(j,ivert)
                   qverta(j,ivert) = qverta(j,ivert)
     *                                - qvertb(j,ivert)
                   rverta(j,ivert) = rverta(j,ivert)
     *                                - rvertb(j,ivert)
                   cverta(j,ivert) = cverta(j,ivert)
     *                                - cvertb(j,ivert)
                   uverta(j,ivert) = uverta(j,ivert)
     *                                - uvertb(j,ivert)
                   wverta(j,ivert) = wverta(j,ivert)
     *                                - wvertb(j,ivert)
  336            continue
  334          continue
             else
               runtita = runtitle
             endif

             zz = 180./pi
             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'T',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
 3149        format('nlat=',i4,' nlev=',i4
     *              /a,5x,'field: ',a,5x,a/9x,18f10.3/)
             do 3150 j=1,nlat
               write(88,3152) zz*alatout(j),(tverta(j,k),k=nlev,1,-1)
 3152          format(f6.2, 3x, 18f10.3)
 3150        continue

             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'Q*1000',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
             do 3160 j=1,nlat
               write(88,3152) zz*alatout(j),(qverta(j,k),k=nlev,1,-1)
 3160        continue

             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'R.H.',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
             do 3170 j=1,nlat
               write(88,3152) zz*alatout(j),(rverta(j,k),k=nlev,1,-1)
 3170        continue

             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'CLOUD',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
             do 3180 j=1,nlat
               write(88,3152) zz*alatout(j),(cverta(j,k),k=nlev,1,-1)
 3180        continue

             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'U',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
             do 3190 j=1,nlat
               write(88,3152) zz*alatout(j),(uverta(j,k),k=nlev,1,-1)
 3190        continue

             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'OMEGA',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
             do 3195 j=1,nlat
               write(88,3152) zz*alatout(j),(wverta(j,k),k=nlev,1,-1)
 3195        continue

c               Integrate V wrt pressure downwards from toa 
c               to get mass stream function (in units of 10^10 kg s-1)
c               (ref: Peixoto and Oort, p.159)

             radius = 6.37122e6
             gravit = 9.80616
             do j=1,nlat
               zfac = 2.*pi*radius*cos(alatout(j))/gravit
               do k=1,nlev
                 zs = 0.
                 do kk=1,k
                   zv = 0.
                   do i=1,nlon
                     ii = i + (j-1)*nlon
                     zv = zv + 100.*arrzc(ii)*arrzh(ii,kk)   !mb to N/m2
                   enddo
                   zs = zs + (zv/nlon)*zfac*dsigma(kk)
                 enddo
                 sverta(j,k) = zs*1.e-10
               enddo
             enddo

             write(88,3149) nlat,nlev,
     *                   runtita(1:lenchr(runtita)), 'STREAMF',
     *                   setper(iper(ip),ifile(ip)),(sig(k),k=nlev,1,-1)
             do j=1,nlat
               write(88,3152) zz*alatout(j),(sverta(j,k),k=nlev,1,-1)
             enddo

 3000        continue
             return
c+++++++++++++++
           endif
c+++++++++++++++


           znulp = -1.e20 ! null value for zonal means

c             Read field into arr...special cases, 
c             followed by default call to readfiel

c---------------------------------------------------
           if (cname(ip,iname)(1:1).eq.'Z'     .and.
     *         cname(ip,iname)     .ne.'Z200'  .and.
     *         cname(ip,iname)     .ne.'Z500'  .and.
     *         cname(ip,iname)     .ne.'Z850' ) then
c---------------------------------------------------

c              "Z.." requests: hard-coded differences and std deviations

             ctmpnam = cname(ip,iname)(2:)
             ctmpnam2 = ctmpnam
c            Assume second set of files (histbatch11-15) are 
c            simple-soil runs with only one soil layer
c888         if (ctmpnam2(1:3).eq.'WET') ctmpnam2(4:) = '1'
c888         if (ctmpnam2(1:4).eq.'WICE') ctmpnam2(5:) = '1'

             ifsdev = .true.
             call readfiel (ctmpnam, iper(ip), ifile(ip),
     *                      1,arrz1,imap,cunits,nlon,nlat,iferr)
             call readfiel (ctmpnam2, iper(ip), ifile(ip)-10,
     *                      1,arrz2,imap,cunits,nlon,nlat,iferr)

             ifsdev = .false.
             call readfiel (ctmpnam, iper(ip), ifile(ip),
     *                      1,arrz3,imap,cunits,nlon,nlat,iferr)
             call readfiel (ctmpnam2, iper(ip), ifile(ip)-10,
     *                      1,arrz4,imap,cunits,nlon,nlat,iferr)

             nyr1 = -ifile(ip)
             nyr2 = -ifile(ip)
             ndof = nyr1 + nyr2 - 2

             if (ndof.eq.8) then
               ztconf10 = 1.860                ! 10% confidence,  8 dof
               ztconf5  = 2.306                !  5% confidence,  8 dof
               ztconf2  = 2.896                !  2% confidence,  8 dof

             else if (ndof.eq.14) then
               ztconf10 = 1.761                 ! 2% confidence, 18 dof
               ztconf5  = 2.145                 ! 5% confidence, 18 dof
               ztconf2  = 2.624                 ! 2% confidence, 18 dof

             else if (ndof.eq.18) then
               ztconf10 = 1.734                 ! 2% confidence, 18 dof
               ztconf5  = 2.101                 ! 5% confidence, 18 dof
               ztconf2  = 2.552                 ! 2% confidence, 18 dof

             else
               write(*,*) 'Error in Dopanel: ndof=',ndof
               stop
             endif

c            Ref: Chervin+Schneider,1976,JAS,33,p.410
             do 301 i=1,nlon*nlat
               zme = arrz4(i)-arrz3(i)
               zva = (nyr1*arrz1(i)**2 + nyr2*arrz2(i)**2) / ndof
               zsd = sqrt (zva * (1./nyr1 + 1./nyr2))
               if (zsd.ge.1.e-10) then
                 zt = abs(zme)/zsd
               else
                 if (abs(zme).ge.1.e-10) then
                   zt = sign (1000., zme)
                 else
                   zt = 0.
                 endif
               endif

               if (level(ip).eq.0) then
                 arr(i) = zme
               else if (level(ip).eq.2) then
                 arr(i) = cvmgt (zme, 0., abs(zt).ge.ztconf2)
               else if (level(ip).eq.5) then
                 arr(i) = cvmgt (zme, 0., abs(zt).ge.ztconf5)
               else if (level(ip).eq.10) then
                 arr(i) = cvmgt (zme, 0., abs(zt).ge.ztconf10)
               else
                 if (zt.ge.ztconf5) then
                   arr(i) = 2.5
                 else if (zt.ge.ztconf10) then
                   arr(i) = 7.5
                 else
                   arr(i) = 55.
                 endif
               endif
               cunits = ' '
  301        continue

c---------------------------------------------------
           else if (cname(ip,iname).eq.'ASCII') then
c---------------------------------------------------

             ifileb = ifile(ip)
             if (ifileb.lt.0) ifilea = ifileb + 10
             if (ifileb.gt.0) ifilea = ifileb - 10
c            if (ifileb.lt.0) ifilea = ifileb - 50   ! stage3
c            if (ifileb.gt.0) ifilea = ifileb + 50   ! stage3

c               Write basic regcm2 data to ascii files

             call readfiel ('LMASK    ', 1, ifileb,
     *                      1, xmask_f, imap, cunits,nlon,nlat,iferr)

             call readfiel ('TOPOGUN  ', 1, ifilea,
     *                      1, topogun_f, imap, cunits,nlon,nlat,iferr)

             do k=1,12
               write (ioterm,310) k
  310          format('doing "ascii" for k=',i2)
               ier = flush(ioterm)

               call readfiel ('TS2     ', k, ifileb,
     *                 1, ts2_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('TS      ', k, ifileb,
     *                 1, ts_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('PRECIP  ', k, ifileb,
     *                 1, precip_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('PME     ', k, ifileb,
     *                 1, pme_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               ifsdevsav = ifsdev
               ifsdev = .true.
               call readfiel ('TS2     ', k, ifileb,
     *                 1, sdt_f(1,1,k), imap, cunits,nlon,nlat,iferr)
               call readfiel('PRECIP  ', k, ifileb,
     *                 1, sdp_f(1,1,k), imap, cunits,nlon,nlat,iferr)
               ifsdev = ifsdevsav

               call readfiel ('WETA3   ', k, ifileb,
     *                 1, weta3_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('PSLEV   ', k, ifilea,
     *                 1, pslev_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('SNOWF   ', k, ifileb,
     *                 1, snowf_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('ICEF    ', k, ifileb,
     *                 1, icef_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('ICEH    ', k, ifileb,
     *                 1, iceh_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('Z500    ', k, ifilea,
     *                 1, z500_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('U       ', k, ifilea,      ! sigma=.251
     *                 8, u8_f(1,1,k), imap, cunits,nlon,nlat,iferr)
               call readfiel ('V       ', k, ifilea,
     *                 8, v8_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('U       ', k, ifilea,      ! sigma=.501
     *                11, u11_f(1,1,k), imap, cunits,nlon,nlat,iferr)
               call readfiel ('V       ', k, ifilea,
     *                11, v11_f(1,1,k), imap, cunits,nlon,nlat,iferr)

               call readfiel ('U       ', k, ifilea,      ! sigma=.866
     *                15, u15_f(1,1,k), imap, cunits,nlon,nlat,iferr)
               call readfiel ('V       ', k, ifilea,
     *                15, v15_f(1,1,k), imap, cunits,nlon,nlat,iferr)

             enddo

             call asciiwrite (70, 'grid',   xmask_f,   ifile(ip), 1)
             call asciiwrite (70, 'topog',  topogun_f, ifile(ip), 1)
             call asciiwrite (70, 'ts2',    ts2_f,     ifile(ip), 12)
             call asciiwrite (70, 'ts',     ts_f,      ifile(ip), 12)
             call asciiwrite (70, 'precip', precip_f,  ifile(ip), 12)
             call asciiwrite (70, 'pme',    pme_f,     ifile(ip), 12)
             call asciiwrite (70, 'sdtemp', sdt_f,     ifile(ip), 12)
             call asciiwrite (70, 'sdprecip',sdp_f,    ifile(ip), 12)
             call asciiwrite (70, 'wsoi',   weta3_f,   ifile(ip), 12)
             call asciiwrite (70, 'slp',    pslev_f,   ifile(ip), 12)
             call asciiwrite (70, 'snowf',  snowf_f,   ifile(ip), 12)
             call asciiwrite (70, 'icef',  icef_f,   ifile(ip), 12)
             call asciiwrite (70, 'iceh',  iceh_f,   ifile(ip), 12)
             call asciiwrite (70, 'z500',  z500_f,   ifile(ip), 12)
             call asciiwrite (70, 'u251',  u8_f,     ifile(ip), 12)
             call asciiwrite (70, 'v251',  v8_f,     ifile(ip), 12)
             call asciiwrite (70, 'u501',  u11_f,    ifile(ip), 12)
             call asciiwrite (70, 'v501',  v11_f,    ifile(ip), 12)
             call asciiwrite (70, 'u866',  u15_f,    ifile(ip), 12)
             call asciiwrite (70, 'v866',  v15_f,    ifile(ip), 12)

             return

c-----------------------------------------------------
           else if (cname(ip,iname)(1:2).eq.'ST') then
c-----------------------------------------------------

c                Storm tracks (s.d. of filtered 500 mb geopot height)

              czf = cname(ip,iname)(3:5)
              czm = cname(ip,iname)(6:8)

              if (czf.eq.'MOD') then
                cfilea = '/sparch/pollard/Runpresa/stormfilt.pres'
              else if (czf.eq.'34A') then
                cfilea = '/sparch/pollard/Run34m2a/stormfilt.34m2a'
              endif

c             set imap,nlon,nlat,runtitle:
              call readfiel ('LMASK   ', 1, ifile(ip),
     *                       1, arr, imap, cunits, nlon,nlat,iferr)

              if (czm.eq.'DJF') then
                cfilea = cfilea(1:lenchr(cfilea)) // '.djf.dat'
              else if (czm.eq.'JJA') then
                cfilea = cfilea(1:lenchr(cfilea)) // '.jja.dat'
              endif

c             Read storm-track filtered 500 mb geopot. sd (dostormfilt) 

              open (70, file=cfilea, status='old')
              read (70,*)
              read (70,'(8f10.3)') zstormt31
              close(70)

c                Convert to primary resolution if necessary

              if (96.ne.$nlona .or. 48.ne.$nlata) then
                if (96.lt.$nlona) then
                  call setmap (96, 48, $nlona, $nlata, .false.)
                  call gtol (zstormt31, arr, 0, 96, 48, $nlona, $nlata)
                else
                  call setmap ($nlona, $nlata, 96, 48, .false.)
                  call ltog (zstormt31, arr, 0, $nlona, $nlata, 96, 48)
                endif
              else
                call scopy (96*48, zstormt31, 1, arr, 1)
              endif

              cunits = 'm'
c             runtitle = 'STORM TRACK_' // czf(1:3) // '_' // czm(1:3)

c------------------------------------------------------
           else if (cname(ip,iname)(1:3).eq.'CCC') then
c------------------------------------------------------

c              CCC monthly files: cname=CCC_[GT,PS,GC,TO,PR,TE,QE,UE,VE]

             call readfielccc
     *          (cname(ip,iname)(5:6)//'      ', iper(ip), ifile(ip),
     *           level(ip), arr, imap, cunits,nlon,nlat,iferr)

c------------------------------------------------------
           else if (cname(ip,iname)(1:3).eq.'CRU') then
c------------------------------------------------------

c               CRU climatological (1980-1990) monthly mean files.
c               cname=CRU_[TOBS,POBS,COBS]. (No imap available)

             call getcru (arr, cunits, cname(ip,1)(5:8), 0,
     *                    xlondum,xlatdum,$nlona,$nlata,iper(ip),if3mon,
     *                    znulp)
             nlev = 1
             sig(1) = 1 
             nlon = $nlona
             nlat = $nlata
             runtitle = '1981 to 1990'

c------------------------------------------------------
           else if (cname(ip,iname)(1:4).eq.'DCCC') then
c------------------------------------------------------

c               CCC minus CRU climatology(1981-1990).
c               cname=DCCC_[GT,TE,PR]

             call readfielccc
     *          (cname(ip,iname)(6:7)//'      ', iper(ip), ifile(ip),
     *           level(ip), arrz1, imap, cunits,nlon,nlat,iferr)

             if (cname(ip,iname)(6:7).eq.'GT' .or.
     *           cname(ip,iname)(6:7).eq.'TE') then
               cztmp = 'TOBS'
             else if (cname(ip,iname)(6:7).eq.'PR') then
               cztmp = 'POBS'
             else
               write (6,*) '** Error: unknown variable name ',
     *         cname(ip,iname)
               stop
             endif

             call getcru (arrz2, cunits, cztmp, 0,
     *                    xlondum,xlatdum,$nlona,$nlata,iper(ip),if3mon,
     *                    znulp)

             do i=1,nlon*nlat
               if (arrz2(i).eq.znulp) then
                 arr(i) = znulp
               else
                 arr(i) = arrz1(i) - arrz2(i)
               endif
             enddo

             runtitle = 'CCCGCM - CRUOBS'

c------------------------------------------------------
           else if (cname(ip,iname)(1:4).eq.'ECCC') then
c------------------------------------------------------

c               CCC (ifile) minus CCC (ifile-10)
c               cname=DCCC_[GT,TE,PR]

             call readfielccc
     *          (cname(ip,iname)(6:7)//'      ', iper(ip), ifile(ip),
     *           level(ip), arrz1, imap, cunits,nlon,nlat,iferr)
             runtita = runtitle

             ifilea = ifile(ip) - isign(10,ifile(ip))
             call readfielccc
     *          (cname(ip,iname)(6:7)//'      ', iper(ip), ifilea,
     *           level(ip), arrz2, imap, cunits,nlon,nlat,iferr)

             do i=1,nlon*nlat
               arr(i) = arrz1(i) - arrz2(i)
             enddo

             runtitle = runtita(1:lenchr(runtita)) // ' minus ' //
     *                  runtitle

c-----------------------------------------------------
           else if (cname(ip,iname)(1:2).eq.'SD') then
c-----------------------------------------------------

             ifsdevsav = ifsdev
             ifsdev = .true.
             call readfiel(cname(ip,iname)(3:)//'  ',iper(ip),ifile(ip),
     *                     level(ip), arr,imap, cunits,nlon,nlat,iferr)
             ifsdev = ifsdevsav

c-----------------------------------------------------
           else if (cname(ip,iname).eq.'O18' .or.
     *              cname(ip,iname).eq.'DO18'.or.
     *              cname(ip,iname).eq.'DH'  .or.
     *              cname(ip,iname).eq.'DEXCESS' .or.
     *              cname(ip,iname).eq.'DDEXCESS' .or. 
     *              cname(ip,iname).eq.'O18TSOI' .or.
     *              cname(ip,iname).eq.'O18BSOI'
     *             ) then
c-----------------------------------------------------

             nloopisot=1
             if (cname(ip,iname).eq.'DO18' .or.
     *           cname(ip,iname).eq.'DDEXCESS') nloopisot=2
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             do iloopisot=1,nloopisot
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             ifilea = ifile(ip)
             if (cname(ip,iname).eq.'DO18') then
               if (iloopisot.eq.2) ifilea = ifilea + isign (10,ifilea)
             endif

             ipp = iper(ip)
             if (cname(ip,iname).eq.'DDEXCESS') then
                if (iloopisot.eq.1) ipp = 1
                if (iloopisot.eq.2) ipp = 7
             endif

             smoj_o = 2.2149e-3
             smoj_h = 3.2883e-4
c            smoj_o = 1.9934e-3 * (20./18.)
c            smoj_h = 0.1557e-3 * (19./18.) * 2.

c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           if (cname(ip,iname).eq.'O18' .or.
     *              cname(ip,iname).eq.'DO18'  .or.
     *              cname(ip,iname).eq.'DH'    .or.
     *              cname(ip,iname).eq.'DEXCESS' .or.
     *              cname(ip,iname).eq.'DDEXCESS'
     *         ) then
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
               call readfiel ('PRECC',    ipp, ifilea,
     *                   level(ip),arrz1,imap,cunits,nlon,nlat,iferr)
               call readfiel ('PRECL',    ipp, ifilea,
     *                   level(ip),arrz2,imap,cunits,nlon,nlat,iferr)

               if (cname(ip,iname).ne.'DH') then
                 call readfiel ('PRECC_O',  ipp, ifilea,
     *                     level(ip),arrz3,imap,cunits,nlon,nlat,iferr)
                 call readfiel ('PRECL_O',  ipp, ifilea,
     *                     level(ip),arrz4,imap,cunits,nlon,nlat,iferr)
               endif
               if (cname(ip,iname).ne.'O18' .and.
     *             cname(ip,iname).ne.'DO18') then
                 call readfiel ('PRECC_H',  ipp, ifilea,
     *                     level(ip),arrz5,imap,cunits,nlon,nlat,iferr)
                 call readfiel ('PRECL_H',  ipp, ifilea,
     *                     level(ip),arrz6,imap,cunits,nlon,nlat,iferr)
               endif
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
             else if (cname(ip,iname).eq.'O18TSOI') then
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
               call readfiel ('HTOPSOIL',    ipp, ifilea,
     *                   level(ip),arrz1,imap,cunits,nlon,nlat,iferr)
               call readfiel ('TOPSOI_O',    ipp, ifilea,
     *                   level(ip),arrz2,imap,cunits,nlon,nlat,iferr)
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
             else if (cname(ip,iname).eq.'O18BSOI') then
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
               call readfiel ('HBOTSOIL',    ipp, ifilea,
     *                   level(ip),arrz1,imap,cunits,nlon,nlat,iferr)
               call readfiel ('BOTSOI_O',    ipp, ifilea,
     *                   level(ip),arrz2,imap,cunits,nlon,nlat,iferr)
c>>>>>>>>>>>>>>>>>
             endif
c>>>>>>>>>>>>>>>>>

             if (cname(ip,iname).eq.'O18' .or. 
     *           cname(ip,iname).eq.'DO18') then
               do i=1,nlon*nlat
                 zpt = max (1.e-20, arrz1(i)+arrz2(i))
                 zpo = arrz3(i) + arrz4(i)
                 arr(i) = 1000.*( (zpo/zpt)/smoj_o - 1. )
               enddo
               if (cname(ip,iname).eq.'DO18') then
                 if (iloopisot.eq.1) then
                    call scopy (nlon*nlat, arr,1,arrsav,1)
                 else if (iloopisot.eq.2) then
                   do i=1,nlon*nlat
                      arr(i) = arrsav(i) - arr(i)
                   enddo
                 endif
               endif

             else if (cname(ip,iname).eq.'DH') then
               do i=1,nlon*nlat
                 zpt = max (1.e-20, arrz1(i)+arrz2(i))
                 zph = arrz5(i) + arrz6(i)
                 arr(i) = 1000.*( (zph/zpt)/smoj_h - 1. )
               enddo

             else if (cname(ip,iname).eq.'DEXCESS'  .or.
     *                cname(ip,iname).eq.'DDEXCESS') then
               do i=1,nlon*nlat
                 zpt = max (1.e-20, arrz1(i)+arrz2(i))
                 zpo = arrz3(i) + arrz4(i)
                 zph = arrz5(i) + arrz6(i)
                 zo18 = 1000.*( (zpo/zpt)/smoj_o - 1. )
                 zdh  = 1000.*( (zph/zpt)/smoj_h - 1. )
                 arr(i) = zdh - 8.*zo18
               enddo
               if (cname(ip,iname).eq.'DDEXCESS') then
                 if (iloopisot.eq.1) then
                    call scopy (nlon*nlat, arr,1,arrsav,1)
                 else if (iloopisot.eq.2) then
                   do i=1,nlon*nlat
                      arr(i) = arrsav(i) - arr(i)
                   enddo
                 endif
               endif

             else if (cname(ip,iname).eq.'O18TSOI' .or. 
     *                cname(ip,iname).eq.'O18BSOI') then
               do i=1,nlon*nlat
                 zpt = max (1.e-20, arrz1(i))
                 zpo = arrz2(i)
                 arr(i) = 1000.*( (zpo/zpt)/smoj_o - 1. )
c777             if (imap(i).eq.0) arr(i) = 0.   ! zero over ocean
               enddo

             endif

             cunits = 'permil'

             globisot = 0
             globarea = 0
             do j=1,nlat
               zonisot(j) = 0.
               zwei = cos ((-90. + ((j-.5)/nlat)*180.)*pi/180.)
               do i=1,nlon
                 n = nlon*(j-1) + i
                 zonisot(j) = zonisot(j) + arr(n)/nlon
                 globisot = globisot + zwei*arr(n)
                 globarea = globarea + zwei
               enddo
             enddo
             globisot = globisot / globarea

             k = ((iabs(ifilea)-1)/10)*10  + 1
             n = lenchr(file(k))
             cisot = file(k)(max(1,n-6):n)

             cfilea = cname(ip,iname)(1:lenchr(cname(ip,iname))) 
     *                //'.'// cisot(1:lenchr(cisot)) // '.tab'

             open (170,file=cfilea, status='unknown')
             close (170, status='delete')
             open (170,file=cfilea, status='new')
             write (170,'("glob=",f9.4)') globisot
             do j=nlat,1,-1
               zlat = -90. + ((j-.5)/nlat)*180.
               write (170,'(f7.2,3x,2f9.4)') zlat, zonisot(j)
             enddo
             close (170)

c~~~~~~~~~~~~~~~~~
             enddo
c~~~~~~~~~~~~~~~~~

c--------------
           else
c--------------

c               Default read of field arr from Genesis history file(s)

             call readfiel (cname(ip,iname), iper(ip), ifile(ip),
     *                      level(ip), arr,imap, cunits,nlon,nlat,iferr)

c---------------
           endif
c---------------

 
c          if (cname(ip,iname).eq.'LMASK') then
c            write (109,'(8e15.8)') (arr(i), i=1,nlon*nlat)
c          endif

c          if (cname(ip,iname).eq.'TS2') then
c            write (110,'(8e15.8)') (arr(i), i=1,nlon*nlat)
c          endif

c          if (cname(ip,iname).eq.'PME') then
c            write (111,'(8e15.8)') (arr(i), i=1,nlon*nlat)
c            do j=1,nlat
c              do i=1,nlon
c                k = (j-1)*nlon + i
c                write (112,'(e20.8)') arr(k)*365.
c              enddo
c            enddo
c          endif
                 
           if (iferr.ne.0) return

c             Compute and save Indian/Himalayan *land* precip

           pindia = -999.
c          if (ifdif.ne.1) then
c            if (cname(ip,iname)     .eq.'PRECIP' .or.
c    *           cname(ip,iname)(1:3).eq.'PRC'    .or.
c    *           cname(ip,iname)     .eq.'P_LECD' ) then
c              pindia = 0.
c              nindia = 0
c              do 320 i=1,nlon*nlat
c                jj = (i-1)/nlon + 1
c                ii = i-(jj-1)*nlon
c                zlat = -90. + 180.*(jj-.5)/nlat
c                zlon = 360.*(ii-.5)/nlon
c                if ( zlat.gt. 0. .and. zlat.lt.32. .and.
c    *                zlon.gt.70. .and. zlon.lt.90. .and.
c    *                imap(i).eq.1 ) then
c                  pindia = pindia + arr(i)
c                  nindia = nindia + 1
c                endif
c 320          continue
c              if (nindia.gt.0) then
c                pindia = pindia/nindia
c              else
c                pindia = -1.
c              endif
c           endif
c         endif

c             Save run title. If difference plot, save field(first loop)
c             or compute difference (second loop).

           if (iloop.eq.1) then
             runtita = runtitle
             if (ifdif.eq.1) then
               do 330 i=1,nlon*nlat
                 arrdif(i) = arr(i) 
  330          continue
             endif
           else 
             runtitb = runtitle
             do 332 i=1,nlon*nlat
               arr(i) = arrdif(i) - arr(i)
  332        continue
           endif
  300    continue

c           Find max absolute value of data

         amax = 0.
         do 40 i=1,nlon*nlat
            amax = max (amax, abs(arr(i))) 
   40    continue

c           Choose scaling factor to retain resol when convert to ints

         anorm = 1.

c-----------------------------------------------------
c method 1, yields max abs nint(value) ge 1 and le 999
c-----------------------------------------------------

c        if (amax.gt.0.) then
c           do 44 i=1,10
c              if (amax*anorm.lt.999.5) goto 46
c              anorm = 10./anorm
c  44       continue
c  46       continue

c           do 48 i=1,10
c              if (amax*anorm.gt.0.5) goto 49
c              anorm = 10.*anorm
c  48       continue
c  49       continue
c        endif

c----------------------------------------------------------
c method 2, yields max abs nint(value) usually close to 999
c----------------------------------------------------------

         if (amax.gt.0.) then
            anorm = 999.4/amax
c           If scaling up, truncate anorm to next lowest integer,
c           to preserve any exact integer values in the real data 
            if (anorm.gt.1.) anorm = int(anorm)
            if (anorm.eq.0.) anorm = 1.
         endif

c           Convert to scaled integer array iarr

         do 50 i=1,nlon*nlat
            iarr(i) = nint (arr(i)*anorm)
   50    continue

c           Tweak anorm to avoid possibility of truncation of integer
c           mask values in gf

         if (cname(ipan,iname).eq.'LMASK'.or.cname(ipan,iname).eq.'ORO')
     *     anorm = .999*anorm

c           Fiddle with particular fields, after "anorm" scaling

         if( cname(ipan,iname)(1:3).eq.'WET'  .or.
     *       cname(ipan,iname)(1:4).eq.'WICE' .or.
     *       cname(ipan,iname).eq.'TRANSP'    .or.
     *       cname(ipan,iname).eq.'TRAVAP'    .or.
     *       cname(ipan,iname).eq.'RUNOFF'    .or.
     *       cname(ipan,iname).eq.'RUNOFT'    .or.
     *       cname(ipan,iname).eq.'DRAIN'     .or. 
     *       cname(ipan,iname).eq.'PHIS'          ) then
           do 54 i=1,nlon*nlat
             if (imap(i).eq.0) iarr(i) = -9999
   54      continue
         else if ( 
     *             cname(ipan,iname).eq.'ICEF'    .or.
     *             cname(ipan,iname).eq.'ICEH'    .or.
     *             cname(ipan,iname).eq.'TSO'     .or.
     *             cname(ipan,iname).eq.'DTSO'    .or.
     *             cname(ipan,iname).eq.'BRINE'   .or.
     *             cname(ipan,iname).eq.'FICEADV' .or.
     *             cname(ipan,iname).eq.'HICEADV' .or.
c    *             cname(ipan,iname).eq.'HOCEAN'  .or.
     *             cname(ipan,iname).eq.'CURLTAU'
     *           ) then
           do 56 i=1,nlon*nlat
             if (imap(i).ne.0) iarr(i) = -9999
   56      continue
         else if ( cname(ipan,iname).eq.'TOCNDIF') then
           do 57 i=1,nlon*nlat
             if (imap(i).ne.0 .or. arr(i).eq.0.) iarr(i) = -9999
   57      continue
         endif

c           Write header lines to gf-input file data. Call
c           globmean to write global means into subtitle (above scaling
c           has not changed arr values), but only for single-field
c           non-expressions since conv cannot evaluate expressions.

         if (iname.eq.1) then

c              Calculate zonal means of first field, save in zonarr

            call zonmean (arr, imap, zonarr, czonarr, zmin, zmax,
     *                    incz, jncz, ipan, nlon, nlat, znulp)
c           if (cname(ip,iname).eq.'PRECIP') then
c             zmin = 0.
c             zmax = 12.
c             incz = 4
c             jncz = 3
c           endif

c           Calculate correl coeff between two fields, set subtitle2

            if (npanel.eq.1) then
              subtitle2 = ' '
            else
              if (ipan.eq.1) then
                do 58 i=1,nlon*nlat
                  arrsav(i) = arr(i)
   58           continue
                subtitle2 = ' '
              else
c               call docorrel (arrsav, arr, nlon, nlat, subtitle2)
              endif
            endif

            if (ifdif.ne.1) then

               clev = 'lev'
               if (cname(ipan,iname)(1:1).eq.'Z' .and.
     *             cname(ipan,1)     .ne.'Z200'  .and.
     *             cname(ipan,1)     .ne.'Z500'  .and.
     *             cname(ipan,1)     .ne.'Z850'      ) clev = 'sig' 

               chmult = setmult(ifile(ipan))
               chper  = setper(iper(ipan), ifile(ipan))
               write(title,600) 
c    *           file(ifile(ipan))(1:lenchr(file(ifile(ipan)))),
     *           runtita(1:min(lenchr(runtita),22)),
     *           cexpr(ipan)(1:lenchr(cexpr(ipan))),
     *           chper(1:lenchr(chper)),
     *           clev,level(ipan),
     *           nint(1000.*sig(max(1,min(nlev,level(ipan))))),
     *           chmult(1:lenchr(chmult))
  600          format(a,'.',
     *                3x,'field: ',a,3x,a,3x, a,':',i2,'(',i4,')',3x,a)

               if (cexpr(ipan).eq.cname(ipan,1)) then
                  call globmean (arr, imap, subtitle, nlon,nlat,
     *                     valg, valn, vals )
               else
                  subtitle = runtita
               endif

            else

               chmult = setmult(ifile(1))
               chper  = setper(iper(1), ifile(1))
               write(title,601) 
c    *           file(ifile(1))(1:lenchr(file(ifile(1)))),
     *           runtita(1:min(lenchr(runtita),22)),
     *           cexpr(1)(1:lenchr(cexpr(1))),
     *           chper(1:lenchr(chper)),
     *           level(1),nint(1000.*sig(max(1,min(nlev,level(1))))),
     *           chmult(1:lenchr(chmult))
  601          format('diff : ',a,'.',
     *                3x,'field: ',a,3x,a,3x,'lev:',i2,'(',i4,')',
     *                3x,a)

               chmult = setmult(ifile(2))
               chper  = setper(iper(2), ifile(2))
               write(subtitle,602) 
c    *           file(ifile(2))(1:lenchr(file(ifile(2)))),
     *           runtitb(1:min(lenchr(runtitb),22)),
     *           cexpr(2)(1:lenchr(cexpr(2))),
     *           chper(1:lenchr(chper)),
     *           level(2),nint(1000.*sig(max(1,min(nlev,level(2))))),
     *           chmult(1:lenchr(chmult))
  602          format('minus: ',a,'.',
     *                3x,'field: ',a,3x,a,3x,'lev:',i2,'(',i4,')',
     *                3x,a)

            endif

c>>>For Stage3>>>
c          iz = (iabs(ifile(ipan))-1)/10 + 1
c          subtitle = cfile(iz)
c          if (cname(ipan,1).ne.'LMASK' .and.
c    *       cname(ipan,1).ne.'TOPOG'  ) then
c            subtitle = subtitle(1:lenchr(subtitle)) //', '// chper(6:)
c          endif
c
c          if (cname(ipan,1).eq.'LMASK') then
c            subtitle2 = 'LAND-OCEAN-ICE MAP'
c          else if (cname(ipan,1).eq.'ICEF') then
c            subtitle2 = 'SEA ICE FRACTION'
c          else if (cname(ipan,1).eq.'SDTS2') then
c            subtitle2 = 'STD. DEV. 2-m AIR TEMPERATURE'
c          else if (cname(ipan,1).eq.'SDPRECIP') then
c            subtitle2 = 'STD. DEV. PRECIPITATION'
c          else if (cname(ipan,1)(1:2).eq.'ST') then
c            subtitle2 = 'STORM TRACK (500 mb geop. std dev)'
c          else if (cname(ipan,1)(1:2).eq.'TS') then
c            subtitle2 = 'SOLID-SURFACE TEMPERATURE'
c          else if (cname(ipan,1).eq.'WETA3') then
c            subtitle2 = 'SOIL MOISTURE, ~30 cm'
c          else if (cname(ipan,1).eq.'PSLEV') then
c            subtitle2 = 'SEA-LEVEL PRESSURE'
c          else if (cname(ipan,1).eq.'U'. or. cname(ipan,1).eq.'V') then
c            subtitle2 = 'WIND'
c          else
c            subtitle2 = cname(ipan,1)
c          endif
c          chlev = ' '
c          if (level(ipan).gt.1 .and. level(ipan).lt.nlev) then
c            k = max (1, min(nlev, level(ipan)))
c            write (chlev,92)  nint(1000.*sig(k))
c  92        format('~',i3,' mb')
c          endif
c
c          if (chlev.ne.' ')
c    *        subtitle2 = subtitle2(1:lenchr(subtitle2)) //
c    *                  ', ' // chlev
c          if (cunits.ne.' ')
c    *        subtitle2 = subtitle2(1:lenchr(subtitle2)) //
c    *                   ' (' // cunits(1:lenchr(cunits)) // ')'
c>>>>>>>>>>>>>>

c           call center (title)
            write(iudata,61) title(1:lenchr(title))
   61       format("title='",a,"'")

c           call center (subtitle)
            write(iudata,62) subtitle(1:lenchr(subtitle)), 
     *                       subtitle2(1:lenchr(subtitle2))
   62       format("subtitle='",a,"'  subtitle2='",a,"'")

            write(iudata,63) nlon,nlat, ipole(ipan), npanel, nname(ipan)
   63       format("nlon=",i4,"  nlat=",i4,"  ipole=",i2,
     *             "  npanel=",i4,"  nname=",i4,"  nhead=6  nterm=9")

            write(iudata,'(a)')
     *        contour(ipan,1)(1:lenchr(contour(ipan,1)))
            write(iudata,'(a)')
     *        contour(ipan,2)(1:lenchr(contour(ipan,2)))

            contmp = ' '
            ix = 1
            do 64 i=3,pcon
              if (contour(ipan,i).ne.' ') then
                contmp(ix:) = contour(ipan,i)
                ix = lenchr(contmp) + 3
              endif
   64       continue
c           set iworld=100 + ifile group (corresp first set of lmasks)
            ix = lenchr(contmp)
            do m=1,ix-5
              if (contmp(m:m+5).eq.'iworld') goto 640
            enddo
            ifilew = (iabs(ifile(ipan))-1)/10 + 1
            write (contmp(ix+3:),'("iworld=",i3)') 100 + ifilew
  640       continue

            write(iudata,'(a)') contmp(1:lenchr(contmp))

         endif

c           Write block of lines for each field to gf-input file
       
         write(iudata,65) cnamez(ipan)(1:lenchr(cnamez(ipan))),
     *                    nlon, nlat, anorm,
     *                    cnamez(ipan)(1:lenchr(cnamez(ipan)))
   65    format("real ",a,"(",i4,",",i4,"), anorm",
     *          "   anorm=",e15.8,
     *          "   readf ",a," '(i5)'")

         write(cform,"('(',i3,'i5)')") nlon
         do 66 j=1,nlat
            write (iudata,cform) (iarr(i+(j-1)*nlon),i=nlon/2+1,nlon), 
     *                           (iarr(i+(j-1)*nlon),i=1,nlon/2)
   66    continue

         write(iudata,67) cnamez(ipan)(1:lenchr(cnamez(ipan))),
     *                    cnamez(ipan)(1:lenchr(cnamez(ipan)))
c        Perturb field by * 1.0001, to avoid a gf problem on cycad
c        caused by exactly equal data values and contour values:
c  67    format(a,'=',a,'/anorm #')
   67    format(a,'= 1.0001*',a,'/anorm #')

c           Write 9 terminal lines to gf-input file. The first evaluates
c           2-d "field", the next declares zonfield* and sets zmin, etc,
c           the next 6 read in zonfield*, and the last is blank.

         if (iname.eq.nname(ipan)) then
            write(iudata,681) cexprz(ipan)(1:lenchr(cexprz(ipan)))
  681       format('field=',a,' #')
            write(iudata,682) nlat, nlat, nlat, zmin, zmax, incz, jncz,
     *                        cunits(1:lenchr(cunits))
  682       format("real:y zonfield (",i4,"),",
     *                   " zonfieldl(",i4,"),",
     *                   " zonfieldo(",i4,")",
     *             "   real zmin,zmax   integer incz,jncz",
     *             "   character cunits(8)",
     *             "   zmin=",e15.8,"   zmax=",e15.8,
     *             "   incz=",i6,   "   jncz=",i6,
     *             "   cunits='",a,"'   anorm=1.")

            write(iudata,683)
  683       format("readf zonfield  '(e13.5)'   .* all:")
            write(cform,"('(',i3,'e13.5)')") nlat
            write(iudata,cform) (zonarr(j,1), j=1,nlat)

            write(iudata,684)
  684       format("readf zonfieldl '(e13.5)'   .* land:")
            write(iudata,cform) (zonarr(j,2), j=1,nlat)

            write(iudata,685)
  685       format("readf zonfieldo '(e13.5)'   .* ocean:")
            write(iudata,cform) (zonarr(j,3), j=1,nlat)
            write(iudata,*)

c           Write title, subtitles to tabular output file

            if (npanel.eq.1) then

              if (cexpr(1).ne.cexprprev) then
                write (iutab,*)
              endif
c             if (cexpr(1).ne.cexprprev) then
                ch1 = setfile(ifile(1)) // ' ' // setmult(ifile(1))
c               write (iutab,690)
c    *            cexpr(1),
c    *            runtitle,
c    *            ch1
                clabout = cexpr(1)
                cunitsout = cunits
c               write (iutab,7000) 
c    *            clabout, cunitsout, valg, valn, vals
c7000           format (': ',a8,' (',a8,') :  global=',e12.4,
c    *                      '  nh=',e12.4,'  sh=',e12.4)
                if (iper(ipan).eq.0 .or. iper(ipan).eq.13) then
                  write (iutab,7000) 
     *            clabout,           valg, valn, vals
 7000             format (': ',a8,':  global=',e11.4,
     *                      '  nh=',e11.4,'  sh=',e11.4)
                else
                  write (iutab,7001) 
     *            clabout, iper(ipan), valg, valn, vals
 7001             format ('  ',a8,'  iper=',i3,'  global=',e11.4,
     *                      '  nh=',e11.4,'  sh=',e11.4)
                endif
                cexprprev = cexpr(1)
c             endif

              chper = setper(iper(1), ifile(1))
c             write (iutab,691)
c    *          chper,
c    *          subtitle(1:lenchr(subtitle))

c             if (pindia.ne.-999.) write (iutab,6912) pindia

c             jinc = max ( 1, (nlat-1)/20 + 1 )
c             jlas = nlat - jinc*((nlat-2)/jinc+1)
c             write (iutab,'(/8x,20f6.1)') 
c    *          (-90+180.*((max(j,1)-.5)/nlat),j=nlat,jlas,-jinc)
c
c             write(iutab,6910) '   all: ',
c    *          (czonarr(max(j,1),1), j=nlat,jlas,-jinc)
c             write(iutab,6910) '  land: ',
c    *          (czonarr(max(j,1),2), j=nlat,jlas,-jinc)
c             write(iutab,6910) '   ocn: ',
c    *          (czonarr(max(j,1),3), j=nlat,jlas,-jinc)

  690         format(
     *          /80('-')
     *         //'field: ',a8,'   title: ',a16,'  file: ',a30)
  691         format(
     *          /2x,a10,3x,a)
 6910         format(a8,20a6)
 6912         format('India land 70-90,0-30:',f7.3)

            else

              runtitsav(ipan) = runtitle
              subtitsav(ipan) = subtitle
              do 700 j=1,nlat
                czonarrsav(j,1,ipan) = czonarr(j,1)
                czonarrsav(j,2,ipan) = czonarr(j,2)
                czonarrsav(j,3,ipan) = czonarr(j,3)
  700         continue
              setpersav(ipan) = setper(iper(ipan),ifile(ipan))
              pindiasav(ipan) = pindia

c-------------------------------------
              if (ipan.eq.npanel) then
c-------------------------------------

              if (cexpr(1).ne.cexprprev) then
c               write (iutab,692)
c               do 702 ip=1,npanel
c                 ch1 = setfile(ifile(ip)) // ' ' // setmult(ifile(ip))
c                 write (iutab ,6920)
c    *              cexpr(ip),
c    *              runtitsav(ip)(1:25),
c    *              ch1
c 702           continue
                cexprprev = cexpr(1)
              endif

c             write (iutab,*)
c             do 704 ip=1,npanel
c               chper = setper(iper(ip), ifile(ip))
c               write (iutab,693)
c    *            chper,
c    *            subtitsav(ip)(1:lenchr(subtitsav(ip)))
c 704         continue
c             write (iutab,6931)
c    *            subtitle2(1:lenchr(subtitle2))

              do 705 ip=1,npanel
                if (pindiasav(ip).ne.-999.) then
c                 if (ip.eq.1) write(iutab,*)
c                 write (iutab,6912) pindiasav(ip)
                endif
  705         continue

c             do 706 ip=1,npanel
c               jinc = max ( 1, (nlat-1)/20 + 1 )
c               jlas = nlat - jinc*((nlat-2)/jinc+1)
c               if (ip.eq.1) write (iutab,'(/8x,20f6.1)') 
c    *            (-90+180.*((max(j,1)-.5)/nlat),j=nlat,jlas,-jinc)
c 
c               write(iutab,*)
c               write(iutab,6910) '   all: ',
c    *            (czonarrsav(max(j,1),1,ip),j=nlat,jlas,-jinc)
c               write(iutab,6910) '   all: ',
c    *            (czonarr   (max(j,1),1,ip),j=nlat,jlas,-jinc)
c
c               write (iutab,*)
c               write(iutab,6910) '  land: ',
c    *            (czonarrsav(max(j,1),2,ip),j=nlat,jlas,-jinc)
c               write(iutab,6910) '  land: ',
c    *            (czonarr   (max(j,1),2,ip),j=nlat,jlas,-jinc)
c
c               write (iutab,*)
c               write(iutab,6910) '   ocn: ',
c    *            (czonarrsav(max(j,1),3,ip),j=nlat,jlas,-jinc)
c               write(iutab,6910) '   ocn: ',
c    *            (czonarr   (max(j,1),3,ip),j=nlat,jlas,-jinc)
c               if (ip.ne.ipanel) write(iutab,*)
c 706         continue

  692         format(/80('-')/)
 6920         format(
     *           'field: ',a8,'   title: ',a16,'   file: ',a30)
  693          format(
     *           2x,a10,3x,a)
 6931         format(
     *           2x,10x,3x,a)

c------------------
              endif
c------------------

           endif

         endif

  100 continue


      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine asciiwrite (iu, cname, arr, jfile, jcode)

c        Writes one ascii file for basic regcm2 results
c        (one line per point, containing all months or seasons)


#include "convcom"

      character*(*) cname
      dimension arr($nlona,$nlata,jcode)

      dimension arra($nlona,$nlata,3)
      character*200 cfilea
      dimension ndaypm(12)
      data ndaypm /31,28,31,30,31,30,31,31,30,31,30,31/

      cfilea = cname(1:lenchr(cname)) // '.' // 'gcm.' // csuffix
c     iz = (iabs(jfile-1)/10) + 1                              ! stage3
c     cfilea = cname(1:lenchr(cname)) // '_'                   ! Stage3
c    *         // cfileasc(iz)(1:lenchr(cfileasc(iz)))  // '.ascgcm'

      open (iu, file=cfilea, status='unknown')
      close(iu, status='delete')
      open (iu, file=cfilea, status='new')

      write (iu,'(a,5x,a)') cfilea(1:lenchr(cfilea)),
     *                      runtitle(1:lenchr(runtitle))
      if (jcode.eq.1) then
        write (iu,'("  i  j     ",a)') cname
      else if (jcode.eq.3) then
        write (iu,'("  i  j       DJF       JJA       ANN")')
      else if (jcode.eq.12) then
        write (iu,'("  i  j       JAN       FEB       MAR       APR",
     *                    "       MAY       JUN       JUL       AUG",
     *                    "       SEP       OCT       NOV       DEC")')
      endif

      if (jcode.eq.1) then

        do j=1,$nlata
          do i=1,$nlona
            write (iu,'(2i3, i10)') i, j, nint(arr(i,j,1))
          enddo
        enddo

      else if (jcode.eq.3) then

        do j=1,$nlata
          do i=1,$nlona
            arra(i,j,1)
     *        = (31*arr(i,j,12) + 31*arr(i,j,1) + 28*arr(i,j,2))
     *          / (31.+31.+28.)
            arra(i,j,2) 
     *        = (30*arr(i,j,6)  + 31*arr(i,j,7) + 31*arr(i,j,8))
     *          / (30.+31.+31.)
            arra(i,j,3) = 0.
            do k=1,12
              arra(i,j,3) = arra(i,j,3) + ndaypm(k)*arr(i,j,k)/365.
            enddo
            write (iu,'(2i3, 3f10.3)') i, j,
     *        (arra(i,j,k),k=1,3)
          enddo
        enddo

      else

        do j=1,$nlata
          do i=1,$nlona
            write (iu,'(2i3, 12f10.3)') i, j, 
     *        (arr(i,j,k),k=1,12)
          enddo
        enddo

      endif

      close(iu)

c        Write diagnostic means 

      write (ioterm,100) cfilea(1:lenchr(cfilea))
  100 format(/'Written file ',a)
      do k=1,jcode
        zmean = 0.
        do j=1,$nlata
          do i=1,$nlona
            if (jcode.eq.2) then
              zmean = zmean + arra(i,j,k)
            else
              zmean = zmean + arr(i,j,k)
            endif
          enddo
        enddo
        zmean = zmean / ($nlona*$nlata)
        write (6,102) k, zmean
  102   format('   k=',i3,'   mean=',f10.3)
      enddo
      ier = flush(6)

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine zonmean (arr, imap, zonarr, czonarr, zminout, zmaxout, 
     *                    incz, jncz, ipan, nlon, nlat, znulp)

c        Calculates zonal means of arr over all/land/ocean, returned
c        in zonarr(*,1-3). Also returns "nice" limits zminout, zmaxout,
c        incz, jncz, for gf. Ignore pts with arr values = znulp.

#include "convcom"

      dimension arr(nlon,nlat), imap(nlon,nlat), zonarr(1000,3)
      character*6 czonarr(1000,3)
      save zmin, zmax
      data zmin, zmax /1.e20, -1.e20/
      data znone /1.e20/


      do 10 j=1,nlat
        zonarr(j,1) = 0.
        zonarr(j,2) = 0.
        zonarr(j,3) = 0.
        nzl = 0
        nzo = 0
        do 12 i=1,nlon
          if (arr(i,j).ne.znulp) then
            zonarr(j,1) = zonarr(j,1) + arr(i,j)

c           imap is 0=ocn/seaice,1=land,2=icesheet (set in readfile)
            if (imap(i,j).ne.0) then
              zonarr(j,2) = zonarr(j,2) + arr(i,j)
              nzl = nzl + 1
            endif
            if (imap(i,j).eq.0) then
              zonarr(j,3) = zonarr(j,3) + arr(i,j)
              nzo = nzo + 1
            endif
          endif
   12   continue

        zonarr(j,1) = zonarr(j,1)/nlon
        if (nzl.gt.0) then
          zonarr(j,2) = zonarr(j,2)/nzl
        else
          zonarr(j,2) = znone
        endif
        if (nzo.gt.0) then
          zonarr(j,3) = zonarr(j,3)/nzo
        else
          zonarr(j,3) = znone
        endif
   10 continue

c        Only reset max, min if first panel, so subsequent panels
c        will also encompass max and mins of all previous panels
c        (gf will use last panel's zminout, zmaxout, etc)

      if (ipan.eq.1) then
        zmin = 1.e20
        zmax = -1.e20
      endif

      do 20 j=1,nlat
        zmin = min (zmin, zonarr(j,1))
        zmax = max (zmax, zonarr(j,1))
        if (zonarr(j,2).ne.znone) then
          zmin = min (zmin, zonarr(j,2))
          zmax = max (zmax, zonarr(j,2))
        endif
        if (zonarr(j,3).ne.znone) then
          zmin = min (zmin, zonarr(j,3))
          zmax = max (zmax, zonarr(j,3))
        endif
   20 continue

      if (abs(zmax-zmin).le.1.e-10) then
        zmax = zmax + 0.5
        zmin = zmin - 0.5
      endif

      zpow = 1.e-15
      do 30 i=-15,15
        if (zpow .gt. zmax-zmin) goto 40
        zpow = zpow*10.
   30 continue

   40 zscal = zpow/100.
      m = (zmax-zmin)/zscal
      if (m.lt.10 .or. m.gt.100) then
        write(*,*) 'Error in zonmean:',
     *  '  zmax=',zmax,'  zmin=',zmin,'  zscal=',zscal,'  m=',m
      endif

      if (m.lt.15) then
        incz = 5
        jncz = 3
        mz = 15
      else if (m.lt.20) then
        incz = 4
        jncz = 5
        mz = 20
      else if (m.lt.30) then
        incz = 6
        jncz = 2
        mz = 30
      else if (m.lt.50) then
        incz = 5
        jncz = 4
        mz = 50
      else if (m.lt.60) then
        incz = 4
        jncz = 5
        mz = 60
      else if (m.lt.80) then
        incz = 8
        jncz = 2
        mz = 80
      else 
        incz = 5
        jncz = 4
        mz = 100
      endif


      zdel = (mz*zscal)/incz
      i = (abs(zmax)/zdel - .01) + 1
      if (zmax.ge.0.) then
        zmaxout = i*zdel
      else
        zmaxout = -(i-1)*zdel
      endif

      incz = (zmaxout-zmin)/zdel + .99 
      zminout = zmaxout - incz*zdel

c     write(*,*)
c     write(*,888) zmin, zmax, zscal, m, mz, incz, jncz,
c                  zminout, zmaxout, zdel
c 888 format('zmin   =',f9.3,' zmax   =',f9.3,' zscal=',f9.3,' m=',i3,
c    *       ' mz=',i3,' incz=',i3,' jncz=',i3
c    *      /'zminout=',f9.3,' zmaxout=',f9.3,' zdel=',f9.3)

      do 50 j=1,nlat
        if (zonarr(j,2).eq.znone) zonarr(j,2) = -9999.
        if (zonarr(j,3).eq.znone) zonarr(j,3) = -9999.
   50 continue

      do 100 m=1,3
        do 102 j=1,nlat
          if (zonarr(j,m).eq.-9999.) then
            czonarr(j,m) = '   ...'
          else if (zmax.le. .9999 .and.zmin.ge.-.9999) then
            write(czonarr(j,m),'(f6.3)') zonarr(j,m)
          else if (zmax.le. 9.999 .and.zmin.ge.-9.999) then
            write(czonarr(j,m),'(f6.2)') zonarr(j,m)
          else if (zmax.le. 99.99 .and.zmin.ge.-99.99) then
            write(czonarr(j,m),'(f6.1)') zonarr(j,m)
c         else if (zmax.le. 999.9 .and.zmin.ge.-999.9) then
c           write(czonarr(j,m),'(f6.0)') zonarr(j,m)
          else 
            write(czonarr(j,m),'(i6)') nint(zonarr(j,m))
          endif
  102   continue
  100 continue

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine globmean (arr, imap, subtitle, nlon, nlat, 
     *                     valg, valn, vals )

c        Calculates various global means and writes them into subtitle

#include "convcom"

      dimension arr(nlon,nlat), imap(nlon,nlat)
      character*(*) subtitle
      parameter (pi=3.14159265358979)


      valg = 0.
      valn = 0.
      vals = 0.
      valn = 0.
      vall = 0.
      valo = 0.
      areg = 0.
      aren = 0.
      ares = 0.
      aren = 0.
      arel = 0.
      areo = 0.
      gmin =  1.e20
      gmax = -1.e20

  
      do 10 j=1,nlat
         darea = cos (-0.5*pi + pi*(j-.5)/nlat) * (pi/(2.*nlon*nlat))

         do 12 i=1,nlon
            areg = areg + darea
            valg = valg + darea*arr(i,j)
            gmin = min (gmin, arr(i,j))
            gmax = max (gmax, arr(i,j))
   12    continue
  
         if (j.le.nlat/2) then
            do 14 i=1,nlon
               ares = ares + darea
               vals = vals + darea*arr(i,j)
   14       continue 
         else
            do 16 i=1,nlon
               aren = aren + darea
               valn = valn + darea*arr(i,j)
   16       continue
         endif
  
         do 18 i=1,nlon
            if (imap(i,j).eq.0) then
               areo = areo + darea
               valo = valo + darea*arr(i,j)
            else
               arel = arel + darea
               vall = vall + darea*arr(i,j)
            endif
   18    continue
   10 continue
  
      if (areg.gt.0.) valg = valg/areg
      if (ares.gt.0.) vals = vals/ares
      if (aren.gt.0.) valn = valn/aren
      if (areo.gt.0.) valo = valo/areo
      if (arel.gt.0.) vall = vall/arel
      
c        Write subtitle line. imap=-1 flags no mask on history file.

      if (imap(1,1).eq.-1) then
         write (subtitle,20) valg, vals, valn
   20    format('globe=',f8.3,'  sh=',f8.3,'  nh=',f8.3)
c        write (subtitle,20) valg, vals, valn, gmin, gmax
c  20    format('globe=',f8.3,'  sh=',f8.3,'   nh=',f8.3,
c    *          ' range=',f8.3,1x,f8.3)
      else
         write (subtitle,22) valg, valo, vall
   22    format('globe=',f8.3,'  ocean=',f8.3,'  land=',f8.3)
c        write (subtitle,22) valg, valo, vall, gmin, gmax
c  22    format('globe=',f8.3,' ocn=',f8.3,' land=',f8.3,
c    *          ' range=',f8.3,1x,f8.3)
      endif

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine docorrel (arr1, arr2, nlon, nlat, subtitle2)

c        Calculates global correlation coefficient between arr1 and arr2

#include "convcom"

      dimension arr1(nlon,nlat), arr2(nlon,nlat), darea(1000)
      character*(*) subtitle2
      parameter (pi=3.14159265358979)


c        global means

      av1 = 0.
      av2 = 0.
      area = 0.
      do 10 j=1,nlat
        darea(j) = cos (-0.5*pi + pi*(j-.5)/nlat) * (pi/(2.*nlon*nlat))
        do 12 i=1,nlon
          av1 = av1 + darea(j)*arr1(i,j)
          av2 = av2 + darea(j)*arr2(i,j)
          area = area + darea(j)
   12   continue
   10 continue
      av1 = av1/area
      av2 = av2/area

c       rms difference (with global means removed)

      rms = 0.
      do 20 j=1,nlat
        do 22 i=1,nlon
          rms = rms + darea(j) * ((arr1(i,j)-av1)-(arr2(i,j)-av2))**2
   22   continue
   20 continue
      rms = sqrt(rms/area)

c       correlation coefficient (first, standard deviations)

      sd1 = 0.
      sd2 = 0.
      do 30 j=1,nlat
        do 32 i=1,nlon
          sd1 = sd1 + darea(j)*(arr1(i,j)-av1)**2
          sd2 = sd2 + darea(j)*(arr2(i,j)-av2)**2
   32   continue
   30 continue
      sd1 = sqrt(sd1/area)
      sd2 = sqrt(sd2/area)

      cor = 0.
      if (sd1.gt.1.e-20 .and. sd2.gt.1.e-20) then
        do 40 j=1,nlat
          do 42 i=1,nlon
            cor = cor 
     *          + darea(j) * ((arr1(i,j)-av1)/sd1)*((arr2(i,j)-av2)/sd2)
   42     continue
   40   continue
        cor = cor/area
      endif

      write (subtitle2, 50) av1-av2, rms, cor
   50 format('dmean=',f8.3,'  rmsdf=',f8.3,'  corr=',f8.3)

      return
      end
c
c-----------------------------------------------------------------------
c
      character*(*) function setmult (ifile)

c        Set output string indicating multi-file averages and
c        standard deviations

#include "convcom"

      if (ifile.lt.0) then
        n = mod (-ifile-1, 10) + 1
        if (ifsdev) then
          write(setmult,550) n
  550     format('mult:',i2,'sd')
        else
          write(setmult,552) n
  552     format('mult:',i2,'av')
        endif
      else
        setmult = ' '
      endif

      return
      end
c
c-----------------------------------------------------------------------
c
      character*(*) function setper (iper, ifile)

c        Set output string indicating month, or days from basedate

#include "convcom"
      character cmon(12)*3, ch*80
      save cmon
      data cmon /'JAN','FEB','MAR','APR','MAY','JUN',
     *           'JUL','AUG','SEP','OCT','NOV','DEC'/

c        Special setting for isccp cloud files (only contain Jan,Jul)
 
      ch = file(abs(ifile))
      lch = lenchr(ch)
      if (ch(lch-8:lch).eq.'isccp_gen' .or.
     *    ch(lch-8:lch).eq.'ISCCP_GEN') then
        if (iper.eq.0) then
          setper = 'mon: ANNUAL'
        else if (iper.eq.1) then
          setper = 'mon: JAN'
        else
          setper = 'mon: JUL'
        endif
        return
      endif

      if (ch(lch-8:lch).eq.'ts2max' .or.
     *    ch(lch-8:lch).eq.'TS2MAX' .or.
     *    ch(lch-8:lch).eq.'ts2min' .or.
     *    ch(lch-8:lch).eq.'TS2MIN' .or.
     *    ch(lch-8:lch).eq.'tpglac' .or.
     *    ch(lch-8:lch).eq.'TPGLAC') then
        setper = 'mon: ANNUAL'
        return
      endif

c        Regular setting

      if (ch(lch-7:lch).eq.'histshea' .or.
     *    ch(lch-7:lch).eq.'HISTSHEA') then
        ndatex = 12
      else
        ndatex = ndate
      endif

      if (iper.eq.0 .or.iper.gt.ndatex) then
        if (ifshowmon) then
          setper = 'mon: ANNUAL'
        else
          setper = 'day: ANNUAL'
        endif
      else
        if (ifshowmon) then
          setper = 'mon: ' // cmon(max(1,min(ndatex,iper)))
          if (iffudge) setper = 'mon: ' // cmon(max(1,min(12,iper)))
          if (if3mon) then
            i  = max(1,min(ndatex,iper))
            im = mod (i-2+ndatex, ndatex) + 1
            ip = mod (i,         ndatex) + 1
            setper = 'mon: '//cmon(im)(1:1)//cmon(i)(1:1)//cmon(ip)(1:1)
          endif
        else
          write(setper,100) dateb(max(1,min(ndate,iper)))
  100     format('day:',f6.1)
        endif
      endif

      return
      end
c
c-----------------------------------------------------------------------
c
      character*(*) function setfile (ifilin)

c        Set output string indicating filename

#include "convcom"

      if (ifilin.ge.0) then
        ifile1 = ifilin
        ifile2 = ifilin
      else
        n = (-ifilin-1)/10 
        ifile1 = 1 + n*10
        ifile2 = -ifilin
      endif

      m = lenchr(file(ifile2))
      n = len(setfile)
      setfile = file(ifile2)(max(m-n+1,1):m)

      return
      end
c
c-----------------------------------------------------------------------
c
      function lenchr (ch)

c        Returns position of last non-blank character in ch, 
c        or 1 if ch is all blanks.

      character*(*) ch

      do 10 i=len(ch),1,-1
         if (ch(i:i).ne.' ') then
            lenchr = i
            return
         endif
   10 continue

      lenchr = 1
      return
      end
c
c----------------------------------------------------------------------
c
      subroutine setmap (nlong, nlatg, nlon, nlat, lcent)
c
c        Sets up weights for transfers between two grids. Almost the
c        same as lsx's setmap, except alat and wgauss are set here
c        since the b-grid may be gaussian. (Comments below are
c        unchanged from lsx.)  Similarly gtol, gtolnear and ltog are
c        the same as lsx's routines, except with includes removed.

c        sets index arrays indg,facg,indl,facl (in commapl) to be used
c        by ltog,gtol to map between ccm grid and lsx grid. 1-d
c        subscripts into the 2-d arrays are used for clarity, ie,
c        kg = ig+nlong*(jg-1) for ccm and kl = i+nlon*(j-1) for lsx.
c        the map from ccm to lsx is done by linear interpolation, and 
c        indg(kl,1-4) = ccm index kg contributing a factor facg(kl,1-4)
c        times its field value at kg to that at kl. (this does not
c        conserve global integrals, so corrections are made in gtol.)
c        the map from lsx to ccm is done by simple "tiling", and
c        indl(kg,1-ntile) = lsx index kl contributing a factor 
c        is the max number of lsx "tiles" that can be overlapped by
c        a ccm grid square (=20 for R15 and 2x2, set in compar).
c
c        also sets weig, weil (in commapl), areas of ccm and lsx boxes
c        relative to whole globe, used by gtol for global integrals.
c
c        the logic here and in vlocat is not general, but assumes that
c        lsx longitude box # 1 starts at 0, and ccm longitude box # 1
c        is centered on 0 (if lcent = true, or starts at 0 if false).
c        this avoids messy wraparound problems. if lcent = true, a 
c        kludge is done for the lsx-to-ccm map by setting the edge
c        (rather than the center) of ccm box # 1 to 0 deg E, then
c        "duplicating" the contributions from lsx boxes in loop 222. 

c-----
      integer plong, platg, plon, plat, ptile
      parameter (plong=180, platg=90, plon=720, plat=360)
      parameter (ptile = (plon/plong+2)*(plat/platg+2))
      parameter (pi=3.14159265358979)
      common /maplsx/
     *  indg (plon*plat,4),             facg (plon*plat,4),
     *  indl (plong*platg,ptile),       facl (plong*platg,ptile),
     *  weig (plong*platg),             weil (plon*plat),
     *  ntile
c-----
      save nlongprev, nlatgprev, nlonprev, nlatprev
      data nlongprev, nlatgprev, nlonprev, nlatprev /0,0,0,0/
c-----

      dimension alatg(platg), wgaussg(platg), alat(plat), wgauss(plat)
c
      dimension alon(plon),
     *          blon(plon+1),   blat(plat+1),
     *          along(plong), 
     *          blong(plong+1), blatg(platg+1),
     *          ig1(plon),      ig2(plon),       p(plon),
     *          jg1(plat),      jg2(plat),       q(plat),
     *          il1(plong),     il2(plong),
     *          jl1(platg),     jl2(platg)
c
      save zero
      data zero /0./

c latitude grid and gaussian weights for Shea dataset (144x73)
      dimension alatshea(73), wgausshea(73)
      data alatshea /
     *  -1.5380778641, -1.4956938027, -1.4530594410, -1.4103685263,
     *  -1.3676561603, -1.3249334148, -1.2822048694, -1.2394727578,
     *  -1.1967382985, -1.1540022123, -1.1112649530, -1.0685268204,
     *  -1.0257880205, -0.9830486996, -0.9403089646, -0.8975688954,
     *  -0.8548285527, -0.8120879840, -0.7693472264, -0.7266063099,
     *  -0.6838652586, -0.6411240925, -0.5983828280, -0.5556414790,
     *  -0.5129000571, -0.4701585724, -0.4274170337, -0.3846754484,
     *  -0.3419338232, -0.2991921640, -0.2564504763, -0.2137087649,
     *  -0.1709670343, -0.1282252886, -0.0854835318, -0.0427417677,
     *   0.0000000000,  0.0427417677,  0.0854835318,  0.1282252886,
     *   0.1709670343,  0.2137087649,  0.2564504763,  0.2991921640,
     *   0.3419338232,  0.3846754484,  0.4274170337,  0.4701585724,
     *   0.5129000571,  0.5556414790,  0.5983828280,  0.6411240925,
     *   0.6838652586,  0.7266063099,  0.7693472264,  0.8120879840,
     *   0.8548285527,  0.8975688954,  0.9403089646,  0.9830486996,
     *   1.0257880205,  1.0685268204,  1.1112649530,  1.1540022123,
     *   1.1967382985,  1.2394727578,  1.2822048694,  1.3249334148,
     *   1.3676561603,  1.4103685263,  1.4530594410,  1.4956938027,
     *   1.5380778641
     *   /
      data wgausshea /
     *   0.0007264094,  0.0015959804,  0.0025057942,  0.0034104452,
     *   0.0043087729,  0.0051992041,  0.0060801287,  0.0069499429,
     *   0.0078070597,  0.0086499146,  0.0094769684,  0.0102867105,
     *   0.0110776620,  0.0118483782,  0.0125974512,  0.0133235129,
     *   0.0140252368,  0.0147013414,  0.0153505914,  0.0159718011,
     *   0.0165638356,  0.0171256135,  0.0176561086,  0.0181543519,
     *   0.0186194333,  0.0190505032,  0.0194467742,  0.0198075225,
     *   0.0201320890,  0.0204198810,  0.0206703726,  0.0208831065,
     *   0.0210576938,  0.0211938158,  0.0212912239,  0.0213497399,
     *   0.0213692572,  0.0213497399,  0.0212912239,  0.0211938158,
     *   0.0210576938,  0.0208831065,  0.0206703726,  0.0204198810,
     *   0.0201320890,  0.0198075225,  0.0194467742,  0.0190505032,
     *   0.0186194333,  0.0181543519,  0.0176561086,  0.0171256135,
     *   0.0165638356,  0.0159718011,  0.0153505914,  0.0147013414,
     *   0.0140252368,  0.0133235129,  0.0125974512,  0.0118483782,
     *   0.0110776620,  0.0102867105,  0.0094769684,  0.0086499146,
     *   0.0078070597,  0.0069499429,  0.0060801287,  0.0051992041,
     *   0.0043087729,  0.0034104452,  0.0025057942,  0.0015959804,
     *   0.0007264094
     *   /

c latitude grid and gaussian weights for Legates dataset (128x64, T42)
      dimension alatlega(64), wgauslega(64)
      data alatlega /
     *  -1.5335125831, -1.4852145780, -1.4366313478, -1.3879836743,
     *  -1.3393115572, -1.2906276131, -1.2419370609, -1.1932424463,
     *  -1.1445451579, -1.0958460175, -1.0471455423, -0.9984440741,
     *  -0.9497418482, -0.9010390314, -0.8523357459, -0.8036320829,
     *  -0.7549281122, -0.7062238881, -0.6575194534, -0.6088148427,
     *  -0.5601100841, -0.5114052007, -0.4627002120, -0.4139951343,
     *  -0.3652899818, -0.3165847667, -0.2678794999, -0.2191741909,
     *  -0.1704688485, -0.1217634809, -0.0730580955, -0.0243526997,
     *   0.0243526997,  0.0730580955,  0.1217634809,  0.1704688485,
     *   0.2191741909,  0.2678794999,  0.3165847667,  0.3652899818,
     *   0.4139951343,  0.4627002120,  0.5114052007,  0.5601100841,
     *   0.6088148427,  0.6575194534,  0.7062238881,  0.7549281122,
     *   0.8036320829,  0.8523357459,  0.9010390314,  0.9497418482,
     *   0.9984440741,  1.0471455423,  1.0958460175,  1.1445451579,
     *   1.1932424463,  1.2419370609,  1.2906276131,  1.3393115572,
     *   1.3879836743,  1.4366313478,  1.4852145780,  1.5335125831
     *   /
      data wgauslega /
     *   0.0018863978,  0.0041436103,  0.0065030767,  0.0088455975,
     *   0.0111668945,  0.0134616378,  0.0157244270,  0.0179499089,
     *   0.0201328104,  0.0222679562,  0.0243502833,  0.0263748531,
     *   0.0283368640,  0.0302316627,  0.0320547548,  0.0338018164,
     *   0.0354687037,  0.0370514630,  0.0385463403,  0.0399497898,
     *   0.0412584828,  0.0424693152,  0.0435794150,  0.0445861493,
     *   0.0454871301,  0.0462802204,  0.0469635392,  0.0475354656,
     *   0.0479946431,  0.0483399827,  0.0485706651,  0.0486861433,
     *   0.0486861433,  0.0485706651,  0.0483399827,  0.0479946431,
     *   0.0475354656,  0.0469635392,  0.0462802204,  0.0454871301,
     *   0.0445861493,  0.0435794150,  0.0424693152,  0.0412584828,
     *   0.0399497898,  0.0385463403,  0.0370514630,  0.0354687037,
     *   0.0338018164,  0.0320547548,  0.0302316627,  0.0283368640,
     *   0.0263748531,  0.0243502833,  0.0222679562,  0.0201328104,
     *   0.0179499089,  0.0157244270,  0.0134616378,  0.0111668945,
     *   0.0088455975,  0.0065030767,  0.0041436103,  0.0018863978
     *   /

c latitude grid and gaussian weights for T10:
      dimension alatt10(16), wgaust10(16)
      data alatt10 /
     * -81.651, -70.835, -59.955, -49.061, -38.161, -27.259,
     * -16.356,  -5.452,   5.452,  16.356,  27.259,  38.161,
     *  49.061,  59.955,  70.835,  81.651 /
      data wgaust10 /
     *  0.0272, 0.0623, 0.0952, 0.1246, 0.1496, 0.1692,
     *  0.1826, 0.1895, 0.1895, 0.1826, 0.1692, 0.1496,
     *  0.1246, 0.0952, 0.0623, 0.0272 /

c latitude grid and gaussian weights for R15 (48x40):
      dimension alatr15(40), wgausr15(40)
      data alatr15 /
     *  -1.5114194265, -1.4345015681, -1.3571294764, -1.2796547655,
     *  -1.2021411419, -1.1246087030, -1.0470657651, -0.9695163873,
     *  -0.8919627867, -0.8144062780, -0.7368476916, -0.6592875794,
     *  -0.5817263241, -0.5041642012, -0.4266014159, -0.3490381260,
     *  -0.2714744570, -0.1939105122, -0.1163463798, -0.0387821385,
     *   0.0387821385,  0.1163463798,  0.1939105122,  0.2714744570,
     *   0.3490381260,  0.4266014159,  0.5041642012,  0.5817263241,
     *   0.6592875794,  0.7368476916,  0.8144062780,  0.8919627867,
     *   0.9695163873,  1.0470657651,  1.1246087030,  1.2021411419,
     *   1.2796547655,  1.3571294764,  1.4345015681,  1.5114194265
     *   /
      data wgausr15 /
     *   0.0045212771,  0.0104982845,  0.0164210584,  0.0222458492,
     *   0.0279370070,  0.0334601953,  0.0387821680,  0.0438709082,
     *   0.0486958076,  0.0532278470,  0.0574397691,  0.0613062425,
     *   0.0648040135,  0.0679120458,  0.0706116474,  0.0728865824,
     *   0.0747231691,  0.0761103619,  0.0770398182,  0.0775059480,
     *   0.0775059480,  0.0770398182,  0.0761103619,  0.0747231691,
     *   0.0728865824,  0.0706116474,  0.0679120458,  0.0648040135,
     *   0.0613062425,  0.0574397691,  0.0532278470,  0.0486958076,
     *   0.0438709082,  0.0387821680,  0.0334601953,  0.0279370070,
     *   0.0222458492,  0.0164210584,  0.0104982845,  0.0045212771
     *   /

c latitude grid and gaussian weights for T31 (96x48):
      dimension alatt31(48), wgaust31(48)
      data alatt31 /
     *  -1.5212131731, -1.4569823009, -1.3923721142, -1.3276762287,
     *  -1.2629478409, -1.1982037311, -1.1334508412, -1.0686925583,
     *  -1.0039307308, -0.9391664533, -0.8744004155, -0.8096330743,
     *  -0.7448647446, -0.6800956510, -0.6153259588, -0.5505557923,
     *  -0.4857852479, -0.4210144016, -0.3562433151, -0.2914720392,
     *  -0.2267006173, -0.1619290868, -0.0971574813, -0.0323858319,
     *   0.0323858319,  0.0971574813,  0.1619290868,  0.2267006173,
     *   0.2914720392,  0.3562433151,  0.4210144016,  0.4857852479,
     *   0.5505557923,  0.6153259588,  0.6800956510,  0.7448647446,
     *   0.8096330743,  0.8744004155,  0.9391664533,  1.0039307308,
     *   1.0686925583,  1.1334508412,  1.1982037311,  1.2629478409,
     *   1.3276762287,  1.3923721142,  1.4569823009,  1.5212131731
     *   /

      data wgaust31 /
     *   0.0031533461,  0.0073275539,  0.0114772346,  0.0155793157,
     *   0.0196161605,  0.0235707608,  0.0274265097,  0.0311672278,
     *   0.0347772226,  0.0382413511,  0.0415450829,  0.0446745609,
     *   0.0476166585,  0.0503590356,  0.0528901895,  0.0551995037,
     *   0.0572772921,  0.0591148397,  0.0607044392,  0.0620394232,
     *   0.0631141923,  0.0639242386,  0.0644661644,  0.0647376968,
     *   0.0647376968,  0.0644661644,  0.0639242386,  0.0631141923,
     *   0.0620394232,  0.0607044392,  0.0591148397,  0.0572772921,
     *   0.0551995037,  0.0528901895,  0.0503590356,  0.0476166585,
     *   0.0446745609,  0.0415450829,  0.0382413511,  0.0347772226,
     *   0.0311672278,  0.0274265097,  0.0235707608,  0.0196161605,
     *   0.0155793157,  0.0114772346,  0.0073275539,  0.0031533461
     *   /

c        lcent is true  for ccm longitude box # 1 centered on 0 deg,
c        or false for that box's western edge at 0 deg. The lsx grid
c        is assumed to have box #1 left-hand edge at 0 deg. 
c
c        If both grids are centered, fake by setting lcent=.false.,
c        as if both grids had edge at 0 deg. If both grids are edged,
c        then lcent=.false. Else lcent=.true. (Can't handle coarse grid
c        edged, fine grid centered).

      logical lcent  
c     save lcent            ! passed as argument now
c     data lcent /.false./

      if (nlong.eq.nlongprev .and. nlatg.eq.nlatgprev .and.
     *    nlon .eq.nlonprev  .and. nlat .eq.nlatprev ) then
        return
      else
        nlongprev = nlong
        nlatgprev = nlatg
        nlonprev  = nlon
        nlatprev  = nlat
      endif

      twopi = 2.*pi
      ntile = (nlon/nlong+2)*(nlat/nlatg+2)

c        Set latitudes and gaussian wts for course grid (called "ccm"
c        or "global" grid in lsx code). Ensure sum of gaussian wts=2.

      if (nlatg.eq.64) then

        do 1 j=1,nlatg
           alatg(j) = alatlega(j)
           wgaussg(j) = wgauslega(j)
    1   continue

      else if (nlatg.eq.73) then

c       do 2 j=1,nlatg
c          alatg(j) = alatshea(j)
c          wgaussg(j) = wgausshea(j)
c   2   continue
        do 2 j=1,nlatg
           alatg(j) = -pi/2. + (j-1.)*pi/(nlatg-1)
           if (j.eq.1 .or. j.eq.nlatg) then
             wgaussg(j) = 1. - sin(pi/2.-.5*pi/(nlatg-1))
           else
             wgaussg(j) = cos(alatg(j))*(pi/(nlatg-1))
           endif
    2   continue

      else if (nlatg.eq.16) then

        do j=1,nlatg
           alatg(j) = alatt10(j)*pi/180.
           wgaussg(j) = wgaust10(j)
        enddo

      else if (nlatg.eq.40) then

        do 3 j=1,nlatg
           alatg(j) = alatr15(j)
           wgaussg(j) = wgausr15(j)
    3   continue

      else if (nlatg.eq.48) then

        do 4 j=1,nlatg
           alatg(j) = alatt31(j)
           wgaussg(j) = wgaust31(j)
    4   continue

      else 

        do 5 j=1,nlatg
           alatg(j) = -pi/2. + (j-0.5)*pi/nlatg
           wgaussg(j) = cos (-pi/2. + pi*(j-.5)/nlatg)
    5   continue

      endif

      wtot = 0.
      do 8 j=1,nlatg
        wtot = wtot + wgaussg(j)
    8 continue
      do 9 j=1,nlatg
        wgaussg(j) = wgaussg(j) * (2./wtot)
    9 continue

c        Set latitudes and gaussian weights for fine grid (called "lsx"
c        grid in lsx code). Ensure that sum of gaussian weights = 2.

      if (nlat.eq.64) then

        do 701 j=1,nlat
           alat(j) = alatlega(j)
           wgauss(j) = wgauslega(j)
  701   continue

      else if (nlat.eq.73) then

c       do 702 j=1,nlat
c          alat(j) = alatshea(j)
c          wgauss(j) = wgausshea(j)
c 702   continue
        do 702 j=1,nlat
           alat(j) = -pi/2. + (j-1.)*pi/(nlat-1)
           if (j.eq.1 .or. j.eq.nlat) then
              wgauss(j) = 1. - sin(pi/2.-.5*pi/(nlat-1))
           else
              wgauss(j) = cos(alat(j))*(pi/(nlat-1))
          endif
  702   continue

      else if (nlat.eq.16) then

        do j=1,nlat
           alat(j) = alatt10(j)
           wgauss(j) = wgaust10(j)
        enddo

      else if (nlat.eq.40) then

        do 703 j=1,nlat
           alat(j) = alatr15(j)
           wgauss(j) = wgausr15(j)
  703   continue

      else if (nlat.eq.48) then

        do 704 j=1,nlat
           alat(j) = alatt31(j)
           wgauss(j) = wgaust31(j)
  704   continue

      else

        do 705 j=1,nlat
           alat(j) = -pi/2. + (j-0.5)*pi/nlat
           wgauss(j) = cos (-pi/2. + pi*(j-.5)/nlat)
  705   continue

      endif

      wtot = 0.
      do 708 j=1,nlat
        wtot = wtot + wgauss(j)
  708 continue
      do 709 j=1,nlat
        wgauss(j) = wgauss(j) * (2./wtot)
  709 continue

c
c        set lsx grids. alon, alat are centers of grid intervals, and 
c        blon, blat are the edges. a sine scale is used for blat, since
c        this is used for the lsx-to-ccm tiling and the area between
c        two latitudes is proportional to d(sin(lat)).
c
      do 10 i=1,nlon
        alon(i) = ((i-.5)/nlon)*twopi
        blon(i) = ((i-1.)/nlon)*twopi
   10 continue
      blon(nlon+1) = twopi
c
      do 12 j=2,nlat
        blat(j) = sin (0.5*(alat(j-1)+alat(j)))
   12 continue
      blat(1) = -1.
      blat(nlat+1) = 1.
c
c        set ccm grids. same comments as for lsx grids apply.
c        if lcent = true, ccm long box # 1 is centered on 0, but
c        set blong(1) to 0 for kludge in loop 222 below.
c        for latitude grid, use gaussian values alatg from ccm.
c
      if (lcent) then
        do 14 ig=1,nlong
          along(ig) = ((ig-1. )/nlong)*twopi
          blong(ig) = ((ig-1.5)/nlong)*twopi
   14   continue
        blong(1) = 0.
        blong(nlong+1) = ((nlong-0.5)/nlong)*twopi
c
      else
        do 15 ig=1,nlong
          along(ig) = ((ig-.5)/nlong)*twopi
          blong(ig) = ((ig-1.)/nlong)*twopi
   15   continue
        blong(nlong+1) = twopi
      endif
c
      blatg(1) = -1.
      do 16 jg=2,nlatg
        blatg(jg) = 0.5 * (sin(alatg(jg-1)) + sin(alatg(jg)))
  16  continue
      blatg(nlatg+1) = 1.
c
c        if ccm and lsx resols are the same, enforce identical grids
c        (already the same for long, but not yet for gaussian lats.)
c
      if (nlon.eq.nlong .and. nlat.eq.nlatg) then
        do 18 j=1,nlat
          alat(j) = alatg(j)
          blat(j) = blatg(j)
  18    continue
        blat(nlat+1) = blatg(nlat+1)
      endif
c
c        set up for main ccm-to-lsx loop 110,112 below. ig1,ig2 are
c        the ccm center-longitudes that bracket each lsx longitude,
c        and p is the relative weight of ig1.
c
      do 100 i=1,nlon
        call vlocat(alon(i), along,nlong, twopi, ig1(i), ig2(i), p(i))
  100 continue
c
c        similarly, jg1,jg2 are the ccm center-latitudes that bracket
c        each lsx latitude, and q is the relative weight of jg1.
c
      do 102 j=1,nlat
        call vlocat(alat(j), alatg,nlatg, zero, jg1(j), jg2(j), q(j))
  102 continue
c
c        main loop to set ccm-to-lsx indices indg, facg. simple linear
c        interpolation is used between the 4 ccm center-points that 
c        surround each lsx center-point.
c
      do 110 j=1,nlat
        do 112 i=1,nlon
          kl = i + nlon*(j-1)
c
          indg(kl,1) = ig1(i) + nlong*(jg1(j)-1)
          facg(kl,1) = p(i) * q(j)
c
          indg(kl,2) = ig2(i) + nlong*(jg1(j)-1)
          facg(kl,2) = (1.-p(i)) * q(j)
c
          indg(kl,3) = ig1(i) + nlong*(jg2(j)-1)
          facg(kl,3) = p(i) * (1.-q(j))
c
          indg(kl,4) = ig2(i) + nlong*(jg2(j)-1)
          facg(kl,4) = (1.-p(i)) * (1.-q(j))
  112   continue
  110 continue
c
c        set up for main lsx-to-ccm loop 210,212 below. jl1-to-jl2 is
c        the range of lsx latitude-intervals that are touched by each
c        ccm latitude-interval. this is done only for efficiency in 
c        loop 210,212 below. 
c
      do 200 jg=1,nlatg
       call vlocat(blatg(jg),   blat,nlat+1, zero, jl1(jg), m, f)
       call vlocat(blatg(jg+1), blat,nlat+1, zero, jl2(jg), m, f)
  200 continue
c
c        similarly, il1-to-il2 is the range of lsx longitude-intervals
c        that are touched by each ccm longitude-interval. 

      do 202 ig=1,nlong
       call vlocat(blong(ig),   blon,nlon+1, twopi, il1(ig), m, f)
       call vlocat(blong(ig+1), blon,nlon+1, twopi, il2(ig), m, f)
  202 continue
c
c        main loop to set lsx-to-ccm indices indl, facl. for each
c        ccm box, the area of overlap with each of the lsx boxes it
c        touches is calculated. indl is the index of each such lsx box,
c        and its overlapped area divided by the ccm-box area is facl.
c
c        if lcent = true, for ccm long box # 1 (with fake blong(1)=0),
c        double the ccm box area areag, and have additional contrib in
c        loop 222 from lsx boxes "reflected" about longitude 0.
c
      do 210 jg=1,nlatg
        do 212 ig=1,nlong
          kg = ig + nlong*(jg-1)
          do 215 l=1,ntile
            indl(kg,l) = 1
            facl(kg,l) = 0.
  215     continue
c
          ng = 0
          areag = (blong(ig+1)-blong(ig)) * (blatg(jg+1)-blatg(jg))
          if (lcent .and. ig.eq.1) areag = 2.*areag
c
          do 220 j=jl1(jg),jl2(jg)
            dy = min(blat(j+1),blatg(jg+1)) - max(blat(j),blatg(jg))
            do 222 i=il1(ig),il2(ig)
              dx = min(blon(i+1),blong(ig+1)) - max(blon(i),blong(ig))
              area = dx*dy
              if (area.gt.0.) then
c
                 ng = ng + 1
                 indl(kg,ng) = i + nlon*(j-1)
                 facl(kg,ng) = area / areag
c
                 if (lcent .and. ig.eq.1) then
                   ng = ng + 1
                   indl(kg,ng) = (nlon+1-i) + nlon*(j-1)
                   facl(kg,ng) = area / areag
                 endif
c
                 if (ng.gt.ntile) then
                    write(6,900) ig,jg,ntile
                    stop
                 endif
c
              endif
  222       continue
  220     continue
c
  212   continue
  210 continue
c
c        set areal weights weil, weig. note sum of wgaussg should = 2.
c        don't forget to double weig for fake blong(1) if lcent = true.
c
      do 300 j=1,nlat
        do 302 i=1,nlon
          kl = i + nlon*(j-1)
          weil(kl) = (wgauss(j)/2.)*((blon(i+1)-blon(i))/twopi)
  302   continue
  300 continue
c
      do 310 jg=1,nlatg
        do 312 ig=1,nlong
          kg = ig + nlong*(jg-1)
          weig(kg) = (wgaussg(jg)/2.)* ((blong(ig+1)-blong(ig))/twopi)
          if (lcent .and. ig.eq.1) weig(kg) = 2.*weig(kg)
  312   continue
  310 continue
c
      return
c
  900 format(/' *** Fatal error ***'/
     *       /' number of lsx overlays for ccm surface grid box',2i4,
     *        ' exceeds limit',i4,' (setmap).'/)
c
      end
c
c----------------------------------------------------------------------
c
      subroutine vlocat (valin, vec, nvec, wrapval, iv1, iv2, frac)
c
c        locates a given value in a monotonic array, and calculates
c        the appropriate linear interpolation factor. the array can
c        wrap around mod(wrapval), or not if wrapval = 0.
c
c        valin   = value to be located. If wrapval ne 0, valin is
c                  shifted mod wrapval (in copy to local variable val)
c                  to be ge 0 and le wrapval (supplied)
c        vec     = array of monotonically increasing, possibly 
c                  irregularly spaced values (supplied)
c        nvec    = size of vec (supplied)
c        wrapval = wraparound value for vec, or zero for no wraparound.
c                  If wrapval ne 0, vec(1) must be ge 0 and vec(nvec)
c                  must be le wrapval. (supplied)
c        iv1,iv2 = indices such that vec(iv1) le val le vec(iv2)
c                  (returned)
c        frac    = linear-interp weighting factor for iv1 (returned)
c
c
      dimension vec(nvec)
c 
c
      if (wrapval.gt.0. .and. (valin.lt.0. .or. valin.gt.wrapval)) then
        val = mod (valin, wrapval)
        if (val.lt.0.) val = val + wrapval
      else
        val = valin
      endif

      if (val.lt.vec(1)) then
         if (wrapval.eq.0.) then
            iv1 = 1
            iv2 = 2
            frac = 1.
         else
            iv1 = nvec
            iv2 = 1
            frac = (vec(1)-val) / (vec(1)+wrapval-vec(nvec))
         endif
c
      else if (val.gt.vec(nvec)) then
         if (wrapval.eq.0.) then
            iv1 = nvec-1
            iv2 = nvec
            frac = 0.
         else
            iv1 = nvec
            iv2 = 1
            frac = (vec(1)+wrapval-val) / (vec(1)+wrapval-vec(nvec))
         endif
c
      else
         do 10 i=2,nvec
            if (val.le.vec(i)) then
               iv1 = i-1
               iv2 = i
               frac = (vec(i)-val) / (vec(i)-vec(i-1))
               return
            endif
   10    continue
c
      endif
c
      return
      end
c
c----------------------------------------------------------------------
c
      subroutine gtol (agcm, alsx, icode, nlong, nlatg, nlon, nlat)
c
c        maps gcm global array agcm to lsx global array alsx. if icode
c        ne 0, corrects alsx to conserve global average either by 
c        adding a constant amount (icode gt 0) or by multiplying by a 
c        constant factor (icode lt 0). the latter is for fields
c        than cannot be negative (eg, rainfall) and/or whose zero
c        values should remain zero (eg, solar flux). for simplicity,
c        1d indices into 2d arrays are used (ie, lon + nlon*(lat-1)).
c        uses index arrays indg,facg and global integral weights
c        weig,weil set up by setmap.
c
c-----
      integer plong, platg, plon, plat, ptile
      parameter (plong=180, platg=90, plon=720, plat=360)
      parameter (ptile = (plon/plong+2)*(plat/platg+2))
      parameter (pi=3.14159265358979)
      common /maplsx/
     *  indg (plon*plat,4),             facg (plon*plat,4),
     *  indl (plong*platg,ptile),       facl (plong*platg,ptile),
     *  weig (plong*platg),             weil (plon*plat),
     *  ntile
c-----
      dimension agcm(plong*platg), alsx(plon*plat)
c
c
c        calculate new lsx field alsx from given ccm field agcm
c
      call zero (alsx, nlon*nlat)
c
      do 10 n=1,4
         do 12 kl=1,nlon*nlat
            alsx(kl) = alsx(kl) + facg(kl,n)*agcm(indg(kl,n))
   12    continue
   10 continue
c
c        if icode ne 0, adjust new lsx fld so global avg is conserved.
c
c     if (icode.eq.0) return
c
      avg = 0.
      do 20 kg=1,nlong*nlatg
        avg = avg + agcm(kg)*weig(kg)
   20 continue
c
      avl = 0.
      do 22 kl=1,nlon*nlat
        avl = avl + alsx(kl)*weil(kl)
   22 continue
c
      if (icode.gt.0) then
        dav = avg-avl
        do 30 kl=1,nlon*nlat
          alsx(kl) = alsx(kl) + dav
   30   continue
      else if (icode.lt.0) then
        if (abs(avl).gt.0.) then
          dav = avg/avl
          do 32 kl=1,nlon*nlat
            alsx(kl) = alsx(kl) * dav
   32     continue
        endif
      endif
c
c     write(6,900) icode,avg,avl
c 900 format('gtol: icode, global means(g,l)=',i2,2e20.10)
c
      return
      end
c
c----------------------------------------------------------------------
c
      subroutine gtolnear (agcm, alsx, nlong, nlatg, nlon, nlat)
c
c        maps gcm global array agcm to lsx global array alsx, simply
c        by taking the nearest ccm neighbor value to each lsx point.
c        used by other dataset generation programs using bats r15 soil
c        texture and color maps. makes use of index arrays indg,facg
c        set up by setmap.
c
c-----
      integer plong, platg, plon, plat, ptile
      parameter (plong=180, platg=90, plon=720, plat=360)
      parameter (ptile = (plon/plong+2)*(plat/platg+2))
      parameter (pi=3.14159265358979)
      common /maplsx/
     *  indg (plon*plat,4),             facg (plon*plat,4),
     *  indl (plong*platg,ptile),       facl (plong*platg,ptile),
     *  weig (plong*platg),             weil (plon*plat),
     *  ntile
c-----
      dimension agcm(plong*platg), alsx(plon*plat)
c
c
      do 10 kl=1,nlon*nlat
        fmax = -1.e20
        do 12 n=1,4
          if (facg(kl,n).gt.fmax) then
            nmax = n
            fmax = facg(kl,n)
          endif
   12   continue
        alsx(kl) = agcm(indg(kl,nmax))
   10 continue
c
      return
      end
c
c----------------------------------------------------------------------
c
      subroutine ltog (alsx, agcm, icode, nlong, nlatg, nlon, nlat)
c
c        maps lsx global array alsx to gcm global array agcm. 
c        similar comments as for gtol apply here, including correction
c        of alsx to conserve global average, either by adding
c        a constant amount (if icode gt 0) or by multiplying by a 
c        constant factor (if icode lt 0). the indices indl, facl
c        used here represent "tiling" (set in setmap), but the
c        global integral is not conserved since the ccm latitudinal
c        integration is by gaussian quadrature, not by adding up the
c        squares.
c
c-----
      integer plong, platg, plon, plat, ptile
      parameter (plong=180, platg=90, plon=720, plat=360)
      parameter (ptile = (plon/plong+2)*(plat/platg+2))
      parameter (pi=3.14159265358979)
      common /maplsx/
     *  indg (plon*plat,4),             facg (plon*plat,4),
     *  indl (plong*platg,ptile),       facl (plong*platg,ptile),
     *  weig (plong*platg),             weil (plon*plat),
     *  ntile
c-----
      dimension alsx(plon*plat), agcm(plong*platg)
c
c
c        calculate new ccm field agcm from given lsx field alsx
c
      call zero (agcm, nlong*nlatg)
c
      do 10 n=1,ntile
         do 12 kg=1,nlong*nlatg
            agcm(kg) = agcm(kg) + facl(kg,n)*alsx(indl(kg,n))
   12    continue
   10 continue
c
c        if icode ne 0, adjust new ccm fld so global avg is conserved.
c
c     if (icode.eq.0) return
c
      avg = 0.
      do 20 kg=1,nlong*nlatg
        avg = avg + agcm(kg)*weig(kg)
   20 continue
c
      avl = 0.
      do 22 kl=1,nlon*nlat
        avl = avl + alsx(kl)*weil(kl)
   22 continue
c
      if (icode.gt.0) then
        dav = avl-avg
        do 30 kg=1,nlong*nlatg
          agcm(kg) = agcm(kg) + dav
   30   continue
      else if (icode.lt.0) then
        if (abs(avg).gt.0.) then
          dav = avl/avg
          do 32 kg=1,nlong*nlatg
            agcm(kg) = agcm(kg) * dav
   32     continue
        endif
      endif
c
c     write(6,900) icode,avl,avg
c 900 format('ltog. icode, global means(g,l)=',i2,2e20.10)
c
      return
      end
c
c----------------------------------------------------------------------
c
      subroutine ltog2 (alsx, agcm, icode, nlong, nlatg, nlon, nlat,
     *                  znulv)
c
c        Same as ltog, except handles null values better (znulv, awei)
c        for getcru
c
c-----
      integer plong, platg, plon, plat, ptile
      parameter (plong=180, platg=90, plon=720, plat=360)
      parameter (ptile = (plon/plong+2)*(plat/platg+2))
      parameter (pi=3.14159265358979)
      common /maplsx/
     *  indg (plon*plat,4),             facg (plon*plat,4),
     *  indl (plong*platg,ptile),       facl (plong*platg,ptile),
     *  weig (plong*platg),             weil (plon*plat),
     *  ntile
c-----
      dimension alsx(plon*plat), agcm(plong*platg), awei(plong*platg)
c
c
c        calculate new ccm field agcm from given lsx field alsx
c
      call zero (agcm, nlong*nlatg)
      call zero (awei, nlong*nlatg)
c
      do 10 n=1,ntile
         do 12 kg=1,nlong*nlatg
            if (alsx(indl(kg,n)).ne.znulv) then
              agcm(kg) = agcm(kg) + facl(kg,n)*alsx(indl(kg,n))
              awei(kg) = awei(kg) + facl(kg,n)
            endif
   12    continue
   10 continue

      do kg=1,nlong*nlatg
        if (awei(kg).gt.0.) then
           agcm(kg) = agcm(kg)/awei(kg)
        else
           agcm(kg) = znulv
        endif
      enddo
c
c        if icode ne 0, adjust new ccm fld so global avg is conserved.
c
c     if (icode.eq.0) return
c
      avg = 0.
      do 20 kg=1,nlong*nlatg
        avg = avg + agcm(kg)*weig(kg)
   20 continue
c
      avl = 0.
      do 22 kl=1,nlon*nlat
        avl = avl + alsx(kl)*weil(kl)
   22 continue
c
      if (icode.gt.0) then
        dav = avl-avg
        do 30 kg=1,nlong*nlatg
          agcm(kg) = agcm(kg) + dav
   30   continue
      else if (icode.lt.0) then
        if (abs(avg).gt.0.) then
          dav = avl/avg
          do 32 kg=1,nlong*nlatg
            agcm(kg) = agcm(kg) * dav
   32     continue
        endif
      endif
c
c     write(6,900) icode,avl,avg
c 900 format('ltog. icode, global means(g,l)=',i2,2e20.10)
c
      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine zero (arr, nar)
c
c        zeros nar words starting at arr(1)
c
      dimension arr(nar)
c
c
      do 10 j=1,nar
        arr(j) = 0.
   10 continue
      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine upper (cin)

c        Upper-cases character string cin

      character*(*) cin

      ia = ichar('a')
      iz = ichar('z')
      ishif = ichar('A') - ichar('a')

      do 10 i=1,len(cin)
        if (ichar(cin(i:i)).ge.ia .and. ichar(cin(i:i)).le.iz)
     *    cin(i:i) = char (ichar(cin(i:i)) + ishif)
   10 continue

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine lower (cin)

c        Lower-cases character string cin

      character*(*) cin

      ia = ichar('A')
      iz = ichar('Z')
      ishif = ichar('A') - ichar('a')

      do 10 i=1,len(cin)
        if (ichar(cin(i:i)).ge.ia .and. ichar(cin(i:i)).le.iz)
     *    cin(i:i) = char (ichar(cin(i:i)) - ishif)
   10 continue

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine lstrip (cin)

c        Strips leading blanks from character string cin

      character*(*) cin
      character*200 ctmp

      do 10 i=1,len(cin)
         if (cin(i:i).ne.' ') then
            ctmp = cin(i:)
            cin = ctmp
            return
         endif
   10 continue

      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine center (cin)

c        Centers non-blank text within cin (ie, so that numbers of
c        leading and trailing blanks become equal).

      character*(*) cin
      character*200 ctmp

      lcin = len(cin)

      do 10 i=1,lcin
         if (cin(i:i).ne.' ') then
            la = i
            goto 12
         endif
   10 continue
      return
   12 continue

      do 20 i=lcin,1,-1
         if (cin(i:i).ne.' ') then
            lb = i
            goto 22
         endif
   20 continue
   22 continue

      nblanks = lcin - (lb-la+1)
      lstart = nblanks/2 + 1

      ctmp = cin
      cin = ' '
      cin(lstart:) = ctmp(la:)

      return
      end
c
c-----------------------------------------------------------------------
c
      SUBROUTINE READDATA (IU, ARRA, ARRB, MLON, MLAT,
     *                     CLABEL, CDESCRIP, ICODE)
C
C        Similar to agcm routine (in util.f), with agcm-specific lines
C        commented out.
C
C        Reads an agcm or lsx data input file, checking on label and
C        dimensions in header record. Data files are ascii, with 1
C        header record, 3 skip records (blank, longitude grid, blank),
C        and MLAT data records. Each data record contains a
C        latitude grid value, followed by MLON data values either
C        in A1 or F5.0 format (flagged by ICODE). The longitudes are
C        western hemisphere first, then eastern, ie, (I=MLON/2+1,MLON),
C        (I=1,MLON/2). The data records are in reverse latitude-grid 
C        order (J=MLAT,1,-1). Data values are returned in *real* array
C        ARRA.
C
C        Permissible characters in A1 format are 0-9, blank(=0),
C        A-Z (=10-35), or a-z(=10-35).
C
C        The ocean current data file has an additional set of 3 skip
C        records and MLAT data records (first set for u, second for v),
C        with the second set returned ion array ARRB.
C        
C        IU = unit number
C        ARRA  = surface array to read rec # 2 into (rec # 1 is header)
C        ARRB  = surface array to read rec # 3 into if any
C        MLON  = longitude dimension
C        MLAT  = latitude  dimension
C        CLABEL = expected 8-byte label in word # 1, rec # 1
C        CDESCRIP = file description (just for messages)
C        ICODE = 1 for A1 format, 2 for F5.0 format.
C
C ---------------------------------------------------------------------
CCALL PARAMS
C ---------------------------------------------------------------------
CCALL COMLUN
C ---------------------------------------------------------------------
      DIMENSION ARRA(MLON,MLAT), ARRB(MLON,MLAT)
      CHARACTER CLABEL*(*), CDESCRIP*(*)
      CHARACTER CARR(360,180)*1, CTMP*8
C ---------------------------------------------------------------------
C
      NOUT = 6
C
C        Find index in program's file list (just for messages)
C
C      CALL FINDIU (IU, LOC)
C
C     WRITE(NOUT,5) CDESCRIP, LOCNAME(LOC)
      WRITE(NOUT,5) CDESCRIP, ' '
   5  FORMAT(/' Reading ',A,' data file ',A)
C
C        Open existing file
C
C     CALL OPENF (IU, 0)
      IREC = 0
C
C        Read header record
C
      IREC = IREC + 1
      READ(IU, 10, ERR=900, IOSTAT=IOS) CTMP, LONZ, LATZ
   10 FORMAT(A8,2I8,8X,A)
      IF (CTMP.NE.CLABEL .OR. LONZ.NE.MLON .OR. LATZ.NE.MLAT) THEN
C        WRITE(NOUT,12) CDESCRIP, LOCNAME(LOC),
         WRITE(NOUT,12) CDESCRIP, ' ',
     *                  CTMP, LONZ, LATZ, CLABEL, MLON, MLAT
   12    FORMAT(/' *** Fatal Error. Incorrect ', A,' data file ',A
     *          /'     File     label, longitude, latitude = ',A8, 2I6
     *          /'     Expected label, longitude, latitude = ',A8, 2I6/)
C        CALL ENDRUN
         STOP
      ENDIF
C
C        Skip 3 records (blank, longitude grid, blank)
C
      IREC = IREC + 3
      READ(IU, 50, ERR=900, IOSTAT=IOS)
   50 FORMAT(//)
C
      IF (ICODE.EQ.1) THEN
C
C          Read "A1-format" data records
C
        DO 100 J=MLAT,1,-1
          IREC = IREC + 1
          READ (IU,102,ERR=900,IOSTAT=IOS) (CARR(I,J),I=MLON/2+1,MLON),
     *                                     (CARR(I,J),I=1,MLON/2)
  102     FORMAT(5X,3X,360A1)
          DO 104 I=1,MLON
            IC = ICHAR(CARR(I,J)(1:1))
            IF (IC.EQ.ICHAR(' ')) THEN
              ARRA(I,J) = 0
            ELSE IF (IC.GE.ICHAR('0') .AND. IC.LE.ICHAR('9')) THEN
              ARRA(I,J) = IC - ICHAR('0')
            ELSE IF (IC.GE.ICHAR('A') .AND. IC.LE.ICHAR('Z')) THEN
              ARRA(I,J) = IC - ICHAR('A') + 10
            ELSE IF (IC.GE.ICHAR('a') .AND. IC.LE.ICHAR('z')) THEN
              ARRA(I,J) = IC - ICHAR('a') + 10
            ELSE
              GOTO 910
            ENDIF
  104     CONTINUE
  100   CONTINUE
C
      ELSE
C
C          Read "F5.0-format" data records
C
        DO 150 J=MLAT,1,-1
          IREC = IREC + 1
          READ (IU,152,ERR=900,IOSTAT=IOS) (ARRA(I,J),I=MLON/2+1,MLON),
     *                                     (ARRA(I,J),I=1,MLON/2)
  152     FORMAT(5X,3X,360F5.0)
  150   CONTINUE
C
      ENDIF
C
C        For ocean currents only, read second field (in "F5.0" format)
C
C     IF (IU.EQ.NOCEAN) THEN
C       Skip 3 records (blank, longitude grid, blank)
C       IREC = IREC + 3
C       READ(IU,200)
C 200   FORMAT(//)
C
C       DO 250 J=MLAT,1,-1
C         IREC = IREC + 1
C         READ (IU,152,ERR=900,IOSTAT=IOS) (ARRB(I,J),I=MLON/2+1,MLON),
C    *                                     (ARRB(I,J),I=1,MLON/2)
C 250   CONTINUE
C     ENDIF
C
C        Close file
C
C     CALL CLOSEF (IU)
      RETURN
C
C        Fatal errors
C
C 900 WRITE(NOUT,902) CDESCRIP, LOCNAME(LOC), IREC, IOS
  900 WRITE(NOUT,902) CDESCRIP, ' ',          IREC, IOS
  902 FORMAT(/' *** Error reading ',A,' data file ',A
     *       /'     record number=',I6
     *       /'     Iostat code  =',I6/)
C     CALL ENDRUN
      STOP
C
C 910 WRITE(NOUT,912) CDESCRIP, LOCNAME(LOC), IREC, I, J, CARR(I,J)
  910 WRITE(NOUT,912) CDESCRIP, ' ',          IREC, I, J, CARR(I,J)
  912 FORMAT(/' *** Bad character in ',A,' data file ',A
     *       /'     record number   =',I6
     *       /'     longitude index =',I6
     *       /'     latitude  index =',I6
     *       /'     bad character   =',A1/)
C     CALL ENDRUN
      STOP
C
      END
c
c-----------------------------------------------------------------------
c
      function cvmgt (x,y,l)

c        Duplicates Cray-Vector-Merge-GT function.
c        Only safe when first two arguments are reals (especially
c        if integers are 32 bits and reals are 64 bits).

      logical l
      if (l) then
        cvmgt = x
      else
        cvmgt = y
      endif
      return
      end
c
c-----------------------------------------------------------------------
c
      subroutine scopy (n, a, inca, b, incb)
c     Duplicates Cray scopy 
      dimension a(*), b(*)
      ib = 1
      do ia=1,n,inca
        b(ib) = a(ia)
        ib = ib + incb
      enddo
      return
      end

      integer function flush (idum)
      flush = 0
      return
      end

      integer function ishell (a)
      character*(*) a
      integer system
c     call system (a, ier)
c     ishell = ier
      ishell = system(a)
      return
      end

ENDconv

#=======================================================================

if ($debug == 0) then
 #set deb = ' '  
  set deb = -g   # for speed in compiling
else 
  set deb = -g
endif

#if ($host == condor) then
#  set FF = /condor/opt/intel_fc_80_32bit/bin/ifort
#else
   set FF = ifort 
#endif

# May need to set -i-static and/or -align depending on linux system: 

 set FFLAGS = ''
 set FFLAGS = "$FFLAGS -i-static"
 set FFLAGS = "$FFLAGS -align"

#if ($host == luna || $host == uranus || $host == neptune) then
#  set FFLAGS = -i-static
#endif

$FF $FFLAGS $deb -w  -r8  -o conv.exe conv.F -L${NA} -lnetcdf
if ($status != 0) exit(0)

# Run program once for each file in the requested list

#=========================
foreach file ( $filelist )
#=========================

  if ($ucase ==  0) then
    set filin = ${file}${append}
  else
    set filin = `echo ${file}${append} | tr "[a-z]" "[A-Z]"`
  endif
  set filin = ${mspath}/${filin}.nc

#----------------------
  if (! -e $filin) then
#----------------------

    echo "Error: input file $filin not found"

#-----
  else
#-----

    if ($append == '') then
      set outfile = `echo conv_${file} | tr "[A-Z]" "[a-z]" `
    else
      set outfile = `echo conl_${file} | tr "[A-Z]" "[a-z]" `
    endif
    if (-e $outfile) then
     #chmod u+w $outfile
      rm -f $outfile
    endif
    touch $outfile
    echo "Reading $filin..."

    if ($debug == 0) then
      conv.exe $filin
      mv out_gcm $outfile
      rm data_gcm
    else
      rm -f core
      idb conv.exe
    endif

#------
  endif
#------

#==
end
#==

rm -f conv.F conv.o conv.exe convcom convnetcom plot.in

exit(0)
